
\chapter{امضای‌دیجیتال}
فرض کنید شخصی به‌نام پگی خواهان باشد تا سندی(دیجیتالی) را (در محیطی ناامن مانند اینترنت) منتشر کند با این ویژگی که سند گویای آن باشد که از طرف پگی می‌باشد و درنتیجه موردتایید وی نیز می‌باشد. بدین منظور پگی باید از پروتکلی به نام امضای دیجیتال که نوعی رمزنگاری نامتقارن می‌باشد، استفاده کند. 
\\
در امضای دیجیتال ، شخصی می‌تواند پیام خود را امضا و آن را منتشر کند و هر شخص دیگری با دیدن پیام و امضا  پی ببرد که آیا پیام دریافت شده از شخص موردنظر می‌باشد یا خیر. بدین منظور لازم است مکانیزمی وجود داشته باشد تا شخص گیرنده پیام ، صحت هویت فرستنده را تایید کند. برای اجرای این سیستم پگی به عنوان امضاکننده می‌تواند از یک کلیدخصوصی برای امضای پیام و از یک کلیدعمومی متناسب با کلید خصوصی (کلید خصوصی و کلید‌عمومی با هم وابسته و مربوط هستند و توسط الگوریتمی مشخص تولید می‌شوند) برای تایید امضا استفاده کند. برای روشن تر شدن بحث یک مثال از امضای دیجیتال بر پایه‌ی مسئله 
$RSA$
ذکر می‌کنیم.
\\
\\
\begin{example}\label{ex_rsa_sig}
	
\textbf{
 امضای دیجیتال 
$\textbf{RSA}$
}\label{ex_ds} {

}

در ابتدا پگی(به عنوان امضاکننده) دو عدد اول بزرگ  
$p$
و
$q$
را به صورت مخفی انتخاب و عدد
$N = p\cdot q$
را به همراه
$v$
 به عنوان کلید‌عمومی(تاییدساز)  منتشر می‌کند. پگی با دانش تجزیه عدد
$N$
، کلیدخصوصی خود یعنی 
$s$
را به دست می‌آورد

$$ sv \equiv 1 \pmod {(p-1) (q-1)}$$

درادامه پگی برای امضای یک سند از کلید خصوصی خود یعنی
$s$
استفاده می‌کند و برای تایید امضا باید از کلید عمومی(تاییدساز)
$v$
استفاده شود.
\RTLfootnote{
اگر سیستم رمزنگاری 
$RSA$
را درنظر بگیریم آنگاه 
$v$
برای رمزنگاری پیام و 
$s$
برای رمزگشایی پیام استفاده می‌شود.
}
برای امضای سند دیجیتالی 
$D$
، فرض می‌کنیم که در محدوده‌ی 
$1 < D < N$
می‌باشد و در ادامه پگی مقدار زیر که معرف امضا می‌باشد را محاسبه و منتشر می‌کند
$$S \equiv D^s \pmod N$$ 
ویکتور(تاییدکننده) برای تایید اعتبار امضای 
$S$
روی سند
$D$
محاسبه زیر را انجام می‌دهد
$$ S^v \pmod N $$
و بررسی می‌کند که آیا جواب برابر با با 
$D$
می‌باشد یا خیر . دلیل این بررسی وجود فرمول اویلر می‌باشد که به رابطه زیر ختم می‌شود
$$ S^v \equiv D^{sv} \equiv D \pmod{N} $$

\end{example}
با مطالعه بیشتر این طرح متوجه می‌شویم که در بطن این پروتکل، دو پروتکل دیگر به نام  احراز‌هویت  و اثبات دانش صفر نیز اجرا می‌شوند به عبارت دیگر با امضای سند، امضاکننده هویت خود را نشان داده است و هر شخصی که سندامضاشده را ببیند متوجه می‌شود که پگی آن را امضا کرده است و درطرف دیگر پروتکل اثبات دانش صفر نیز انجام شده است به این صورت که بدون آن‌که دانش امضاکننده یعنی کلیدخصوصی افشا شود، ویکتور(تاییدکننده) توانسته است امضا را با استفاده از کلیدعمومی(تاییدساز) که توسط امضاکننده همراه با پیام  منتشر شده بود تاییدکند. بنابراین نتیجه می‌گیریم که پروتکل امضا براساس پروتکلی به‌نام اثبات‌دانش‌صفر‌هویت پیاده‌سازی می‌شود.

% ==========================================================================================
% ZKP of Identity
% ==========================================================================================

\section{اثبات دانش صفر هویت}\LTRfootnote{Zero-Knowledge Proof of Identity}\label{ZKPOI}

به‌طور رسمی، یک سیستم اثبات دانش صفر یک رویه است که طی آن پگی(به‌عنوان شخص اثبات‌کننده)، ویکتور(به‌عنوان شخصی تاییدکننده) را متقاعد می‌کند که به یک حقیقت معین  
\RTLfootnote{
حقیقت می‌تواند هویت اثبات‌کننده (پگی) ‌باشد.
}
اشراف دارد بطوریکه هیچ اطلاعات اضافی نسبت به دانش خود در اختیار ویکتور قرار نمی‌دهد تا خود ویکتور نتواند به عنوان یک مدعی دیگران را متقاعد کند که به حقیقت مورد بحث اشراف دارد. برای توضیح بیشتر این پروتکل مثالی ارائه می‌کنیم.
\begin{example}\label{ex_zkp}\textbf{اثبات دانش صفر}
	
فرض کنید دو لیوان شفاف در اختیار داریم که یکی حاوی آبِ خالص و دیگری حاوی آب با مخلوطی شفاف می‌باشد که فقط پگی فرق این دو لیوان را می‌داند. حال برای آن‌که پگی به ویکتور ثابت کند که دانش لازم را برای تشخیص لیوان حاوی آب خالص و لیوان آب ناخالص را در اختیار دارد می‌بایست به چالش‌هایی که از طرف ویکتور مورد سوال قرار می‌گیرد به درستی جواب بدهد. ویکتور برای اطمینان از اینکه پگی واقعا دانش لازم این اثبات را می‌داند می‌تواند چالش‌های خود را چندین بار تکرار کند و اگر پگی در تمامی چالش‌ها به درستی جواب بدهد آنگاه مطمئن می‌شود که پگی دانش لازم را دراختیار دارد. پگی برای آن‌که مستقیما دانش خود را افشا نکند لیوان حاوی آب خالص را به ویکتور نشان نمی‌دهد و در عوض مراحل زیر به تعداد مشخصی تکرار می‌شود
\begin{enumerate}
	\item 
	ابتدا پگی به عنوان اثبات‌کننده ادعا می‌کند که مکان لیوان‌ حاوی آب ناخالص  را می‌داند.
	\item 
 پگی چشمان خود را با چشم‌بند می‌بندد و سپس	ویکتور به‌عنوان یک  چالش ، یا جای دو ظرف آب را باهم جا‌به‌جا می‌کند یا بدون تغییر آن‌ها آماده پاسخ چالش خود می‌شود
	\item 
	پگی چشم‌بند را از چشمان خود برمی‌دارد و با اتکا به دانشی که در اختیار دارد مشخص می‌کند که آیا جای این دو لیوان عوض شده است یا خیر
	\item 
	اگر پگی به درستی تشخیص دهد که جای لیوان‌ها عوض شده است یا خیر  آنگاه ویکتور برای اطمینان از شانسی نبودن جواب پگی می‌تواند بار دیگر مراحل را با همکاری پگی تکرارکند اما اگر حتی یک بار پگی به اشتباه جواب چالش پگی را بدهد آنگاه ویکتور با اطمینان ادعای پگی را نمی‌پذیرد.
\end{enumerate}~
\\
ذکر این نکته لازم است که اگر پگی به صورت شانسی به چالش جواب بدهد به احتمال
$1/2$
به طور صحیح  جواب داده است ، حال اگر  که رویه اثبات به تعداد 
$n$
بار تکرار شود آنگاه به احتمال 
$1 / 2^n$
 پگی به صورت شانسی جواب چالش‌ها را  به درستی داده است ، همان‌گونه که مشخص است تقریبا محال است که همچین اتفاقی رخ دهد و پگی قادر باشد که تمام جواب‌ها را به صورت شانسی جواب داده باشد. بنابریان ویکتور با تکرار رویه اثبات و جواب صحیح پگی در هر مرحله، کاملا قانع می‌شود که پگی به دانش ادعا شده اشراف دارد.

\end{example}~
\\
برای پیاده‌سازی پروتکل‌اثبات‌دانش‌صفر به صورت ریاضی، درادامه طرحی براساس همسانی بین  خم‌های سوپرسینگولار ارائه می‌کنیم.  
\\
\\
در طرحی که خواهان ارائه آن هستیم به خم‌های سوپرسینگولار با درجه‌ای هموار
\RTLfootnote{
در مبحث خم‌های سوپرسینگولار، ساخت خم‌های با درجه هموار آسان می‌باشد و با استفاده از این خم‌ها می‌توان تعداد زیادی همسانی بین آنها ساخت که خیلی سریع قابل محاسبه هستند.
}
 نیاز می‌باشد بنابراین ابتدا  عدد اولی به فرم 
$p = \ell_A^{e_A} \ell_B^{e_B} \cdot f \pm 1$
را انتخاب می‌کنیم که 
$\ell_A$
و
$\ell_B$
اعداد اول کوچک (معمولا ۲ و ۳) می‌باشند با این خاصیت که طول ارقام
$\ell_A^{e_A}$
و
$\ell_B^{e_B} $
برابر باشد (در بخش ۶ به طور مفصل آن را بررسی خواهیم کرد) و همچنین  
$f$ % section 6 dont defind until now !!!!!!!!!!!!!!!!!!!!!!!!
یک عامل کوچک است که باعث می‌شود 
$p$
یک عدد اول شود. در ادامه ‌با روش بروکر 
\cite{broker@constructing}
، یک خم سوپرسینگولار 
$E$
را روی میدان 
$F_{p^2}$
با مرتبه‌ی 
$(\ell_A^{e_A} \ell_B^{e_B})^2$
 به دست می‌آوریم. سپس دو زیرگروه 
$E[\ell_A^{e_A}]$
و
$E[\ell_B^{e_B}]$ 
که مولدهای آن به ترتیب به صورت زوج نقاط
$ \langle P_A,Q_A \rangle $
و
$ \langle P_B,Q_B \rangle  $
می‌باشند را روی خم 
$E$
محاسبه می‌کنیم.
\\
\\
طرح اثبات دانش صفری براساس همسانی‌ها مطابق شکل 
\ref{fig:zkp}
 صورت می‌گیرد. پگی به عنوان اثبات کننده، نقطه 
$S$
که تولیدکننده هسته همسانی 
$\phi : E \rightarrow E/ \langle S \rangle $
می‌باشد را به عنوان دانش  صفر، به صورت مخفی نزد خود نگه  می‌دارد. 
و بر این اساس، کلید خصوصی و کلیدعمومی پگی به‌صورت زیر معرفی می‌شود :

\begin{itemize}
\item {\textbf{کلید خصوصی :} }
هسته همسانی
$\phi$
یعنی
$S$

\item {\textbf{کلید عمومی :} }
خم بیضوی
$E/ \langle S \rangle$
و تصویر نقاط  
$P_B$ 
و
$Q_B$
یعنی
$\phi(P_B)$
و	
$\phi(Q_B)$	
\end{itemize}~ 
% ==============================================================================================
% figure 1 for demonstrate zer-konwledge proof of identity
\begin{figure}[H] 
	\begin{center}
		
		\begin{tikzcd}
			E \arrow[r, "\phi"] \arrow[d, "\psi"] & E/ \langle S \rangle \arrow[d, "{\psi}' "] \\
			E/ \langle R \rangle \arrow[r, "{\phi}' "] & E/\langle R,S \rangle
		\end{tikzcd}
		
		\caption{
			هر فلش با همسانی و و هسته‌اش نشانه گذاری شده است    
		}
		\label{fig:zkp}
		
	\end{center}
\end{figure}
% ==============================================================================================
\vskip 0.5in

حال پگی برای آن که به ویکتور (تاییدکننده) ثابت کند که دانش 
$\langle S \rangle $
را می‌داند ، مراحل زیر به ترتیب انجام می‌شود:
 % ===========================================================================================
\iffalse
یک نقطه تصادفی 
$R$
از مرتبه‌ی
$\ell_B^{e_B}$
انتخاب و همسانی 
$\psi = E \rightarrow E / \langle R \rangle$
را تعریف می‌کند. 
% به عبارت دیگر طرح شکل ۱ ؟؟؟ هست.
% اثبات را بعدا در پایان نامه بیاورم !!!
درادامه پگی همسانی‌های طرح ارائه شده در شکل 
\ref{fig:zkp}
 را محاسبه و خم‌های 
$E_1 = E / \langle R \rangle$
و
$E_2 = E / \langle R,S \rangle $
 را برای  ویکتور ارسال می‌کند. 
\\
 در ادامه ویکتور بیت چالشی خود،
$b \in \{0,1\}$
را انتخاب و برای پگی ارسال می‌کندو متعاقبا پگی همسانی‌ای  (که عمومی نمی‌باشد)  مطابق با چالش انتخابی ویکتور برای وی ارسال می‌کند تا ویکتور آنها را تایید کند.\\
\fi
% ===========================================================================================
 %برای فهم و تشریح بیشتر این پروتکل آن را به صورت الگوریتمیک نشان می‌دهیم :
\begin{enumerate}
	
\item {
\begin{itemize}
\item 
پگی یک نقطه تصادفی 
$R$
از مرتبه‌ی
$\ell_B^{e_B}$
انتخاب می‌کند.
	
\item 
او همسانی
$\psi : E \rightarrow E / \langle R \rangle$
را محاسبه می‌کند.
\item 
پگی در ادامه همسانی
${\phi}' : E / \langle R \rangle \rightarrow  E / \langle R,S \rangle $
را به همراه هسته
$\langle \psi(S) \rangle$
و از سوی دیگر همسانی   
${\psi}' : E / \langle S \rangle \rightarrow  E / \langle R,S \rangle $
را به همراه هسته 
$\langle \phi(R) \rangle$

 محاسبه می‌کند.
 \item 
 پس از محاسبات بالا ، پگی تعهد 
 \LTRfootnote{commitment}
 $com = (E_1 , E_2)$
 که 
 $E_1 = E / \langle R \rangle$
 و
 $E_2 = E / \langle R,S \rangle$
‌ را برای ویکتور ارسال می‌کند.
 
\end{itemize}	
} % end item

\item 
ویکتور به طور تصادفی  بیت چالشی 
$ch \in \{0,1\}$
را انتحاب و برای پگی ارسال می‌کند.
\item 
پگی پاسخ 
$resp$
را برای ویکتور ارسال می‌کند :
\begin{itemize}
	\item
	اگر 
	$ch = 0$
	آنگاه
	$resp = (R,\phi(R))$
	
	\item
	اگر 
	$ch = 1$
	آنگاه
	$resp = \psi(S)$
	
\end{itemize}
\item {
\begin{itemize}
	\item 
	اگر
	$ch = 0 $
	، ویکتور تایید می‌کند که
	$R$
	و
	$\phi(R)$
	هردو از مرتبه‌ی 
	$\ell_B^{e_B}$
	هستند و هسته‌های همسانی‌های
	$E \rightarrow E_1$
	و 
	$E/ \langle S \rangle \rightarrow E_2$
	را تولید می‌کنند.
	\item 
	اگر 
	$ch = 1 $
	، ویکتور تایید می‌کند که 
	$\psi(S)$
	از مرتبه‌ی
	$\ell_A^{e_A}$
	است و هسته‌ی همسانی 
	$E_1 \rightarrow E_2$
	را تولید می‌کند.
\end{itemize}
} % end item
	
	
\end{enumerate}

% ==============================================================================================
% fugure 2 for demostrate DSSP assumption for chaaleng ????
\begin{figure}[ H]
	\centering
	% ----------------------------------------------------------------
	\begin{subfigure}{0.4\textwidth}
		\centering
		%\includegraphics[width=.4\linewidth]
		\caption{b = 0}
		\label{fig:sub1}
		\begin{tikzcd}
			E \arrow[r, dashrightarrow , "\phi"] \arrow[d, "\psi"] & E/ \langle S \rangle \arrow[d, "{\psi}' "] \\
			E/ \langle R \rangle \arrow[r, dashrightarrow ,"{\phi}' "] & E/\langle R,S \rangle
		\end{tikzcd}
		
	\end{subfigure}
	% -------------------------------------------------------------------
	
	% ---------------------------------------------------------------------
	\begin{subfigure}{0.4\textwidth}
		\centering
		%\includegraphics[width=.4\linewidth]
		\caption{b = 1}
		\label{fig:sub2}
		\begin{tikzcd}
			E \arrow[r, dashrightarrow , "\phi"] \arrow[d, dashrightarrow , "\psi"] & E/ \langle S \rangle \arrow[d, dashrightarrow , "{\psi}' "] \\
			E/ \langle R \rangle \arrow[r, "{\phi}' "] & E/\langle R,S \rangle
		\end{tikzcd}
		
	\end{subfigure}%
	% -------------------------------------------------------------------
	\caption{
		همسانی‌های مخفی با خط‌های مقطع نماش داده شده است. خط های توپر نمایش دهنده همسانی‌هایی می‌باشد که پگی نسبت به چالش انجام شده ظاهر می‌کند. با این حال همسانی‌های ظاهرشده هیچ اطلاعاتی درباره همسانی مخفی
		$\phi$
		افشا نمی‌کند.	
	}
	\label{fig:challenge}
\end{figure}~
% ==============================================================================================
\\
 برای دست‌یابی به 
$\lambda$
بیت امنیت، لازم است که عدد اول
$p$
دقیقا 
$6\lambda$
بیت باشد(دلیل این امر در بخش ۶ ذکر شده است) و پروتکل 
$\lambda$
بار تکرار شود. اگر ویکتور(تاییدکننده) تمام
$\lambda$
بار تکرار پروتکل را با موفقیت تایید کند آنگاه پگی(اثبات‌کننده) توانسته است ادعای خود مبنی بر دانش کلیدخصوصی
$S$
را برای ویکتور اثبات کند، در غیراینصورت ادعا توسط ویکتور موردقبول قرار نمی‌گیرد.
\\
\\
لاز به ذکر است که در هربار اجرای این طرح، نقطه
$R$
کاملا به صورت تصادفی انتخاب می‌شود و براساس این نقطه شکل
\ref{fig:zkp}
حاصل می‌شود و بنابراین همسانی‌ها و خم‌های هر بار اجرای این پروتکل با دفعه قبل کاملا فرق دارد و فقط خم 
$E / \langle S \rangle $
ثابت باقی می‌ماند. چنان‌که در بخش 
\ref{security}
خواهیم دید اگر همسانی‌های 
$\psi$
و
${\psi}'$
و
${\phi}'$
همزمان معلوم شوند، دانش  
$S$
 قابل کشف است بنابراین برای جلوگیری از افشای 
 $S$
 در هر بار تکرار رویه اثبات با چالش 
 $ch = 0 $
 همسانی‌های 
 $\psi$
 و
 ${\phi}'$ 
 عمومی می‌شوند و با چالش
 $ch = 1$
 تنها همسانی 
 ${\phi}'$ 
 عمومی می‌شود تا طرح ما ایمن باقی بماند.
 







% ==========================================================================================
% Unrah Construction
% ==========================================================================================

\section{ساخت آنره}\LTRfootnote{Unruh's Construction}\label{unruh}

برای ساخت یک سیستم امضای دیجیتال برپایه‌ی پروتکل اثبات‌دانش‌صفر معرفی شده در بخش قبل لازم است در پروتکل تغییراتی صورت گیرد. به عبارت دیگر چنان‌که در توضیحات بخش قبلی ملاحظه شد در پروتکل اثبات‌دانش‌صفر نیاز است که بین اثبات‌کننده و تاییدکننده یک تعامل دوسویه برقرار باشد یعنی هنگامی که پگی قصد دارد تا دانشی را به ویکتور اثبات کند لازم است که به چالش‌هایی که از طرف ویکتور می‌آید پاسخی مناسب داده شود  اما همان‌طور که در امضای دیجیتال مشاهده شد برای اثبات یک دانش (هویت امضاکننده) لزومی به ارتباط دوسویه بین اثبات‌کننده و تاییدکننده نمی‌باشد به عبارت دیگر برای آنکه تاییدکننده قانع شود که امضا(اثبات) از طرف امضاکننده است لزومی ندارد تا با امضاکننده در ارتباط باشد و تنها کافی است با کلیدعمومی منتشر شده توسط امضاکننده به بررسی و تایید امضا بپردازد. 
\\
برای آن که بتوانیم از طریق پروتکل اثبات دانش صفر هویت به امضای دیجیتال برسیم لازم است طرح اولیه خود که به سیستم اثبات تعاملی 
\LTRfootnote{Interactive Proof System}
معروف است را به یک سیستم اثبات غیرتعاملی
\LTRfootnote{Non-interactive Proof System}
 تبدیل کنیم. اولین بار فیات و شمیر طرحی با نام خود ارائه کردند
\cite{fiat@prove}
که یک سیستم اثبات دانش صفر تعاملی را به یک سیستم اثبات دانش صفر غیرتعاملی تبدیل می‌کرد ولی به دلیل آن که این طرح در برابر حملات کوانتومی ایمن نبود، اخیرا آنره در
\cite{unruh}
سیستمی  جدید را معرفی کرده است که برخلاف طرح فیات-شمیر در برابر حملات کوانتومی نیز ایمن می باشد. بنابراین در ادامه به معرفی طرح ارائه شده توسط آنره می‌پردازیم که یک سیستم اثبات تعاملی با ویژگی‌های خاص به نام پروتکل زیگما را به یک سیستم اثبات دانش صفر غیرتعاملی تبدیل می‌کند که برای ساخت طرح امضای دیجیتالی مقاوم کوانتومی خود از این طرح سود می‌بریم.
% comment -------------------------------------------------------------
\iffalse
یک سیستم اثبات دانش صفر تعاملی را به سیستم اثبات دانش صفر غیرتعاملی متناظر با آن انتقال می‌دهد. این ساخت ، ویژگی استخراج آنلاین
\LTRfootnote{online extractability}
را که اجازه می‌دهد شاهد(کلید خصوصی) را از یک متخاصم موفق بدون چرخش
\LTRfootnote{rewinding}
استخراج کنیم ، را دارا می‌باشد.
\fi
% مطالب بیشتر مقاله باید تحقیق شود
% comment -----------------------------------------------------------------------------------
\iffalse
در ابتدای امر این فرص را داریم که تمام بخش های این پروتکل به یک اوراکل تصادفی کوانتومی 
\LTRfootnote{quantum random oracle}
$H$
دسترسی دارند.
% ادامه باید بررسی شود !!!
\fi
\\
\\
در یک سیستم اثبات ، اثبات کننده 
$\mathcal{P}$
خواهان آن است تا اظهار 
$x$
را برای تاییدکننده 
$\mathcal{V}$
اثبات کند با این ویژگی که برای متقاعد کردن تاییدکننده برای اظهار
$x$
، شاهد 
$w$
را برای ادعای خود در اختیار دارد. در هر پروتکل اثبات یک رابطه باینری به نام 
$R$
وجود دارد، به این معنی که اگر اظهار
\LTRfootnote{Statement}
$x$
ادعا ‌شود آنگاه باید شاهدی
\LTRfootnote{Witness}
به نام 
$w$
برای آن موجود باشد که در این صورت آن را به صورت 
$(x,w) \in R $
نمایش خواهیم داد. به طور مثال در امضای دیجیتال اگر کلید عمومی 
$v$
برای امضای
$S$
ادعا شود آنگاه کلیدخصوصی
$s$
به عنوان شاهدی برای کلیدعمومی می‌باشد که رابطه‌ی این دو به صورت زیر تعریف می‌شود:
$$(v,s) \in R ~ ; \quad R :\{ ~ ‌sv \equiv 1  \mod ( (p-1)(q-1) )  \} $$
به عبارت دیگر اگر کلید عمومی (ادعا) منتشر شده با کلیدخصوصی(شاهد)  امضاکننده واقعا رابطه‌ای داشته باشند آنگاه برای هر چالشی که توسط تاییدکننده (در اینجا چالش ، پیام 
$m$
می‌باشد) برای امضاکننده (اثبات‌کننده)ارسال می‌شود، باید بعداز دریافت امضای پیام بتوانیم با کلیدعمومی به پیام ارسال شده برسیم . بنابراین زمانی ادعای امضاکننده مبنی بر داشتن شاهد یا کلیدخصوصی محرز می‌شود که بتوانیم با کلیدعمومی منتشر شده توسط وی به پیام برسیم ،در غیراینصورت ادعا موردقبول واقع نمی‌شود و درنتیجه آشکار می‌شود که رابطه‌ای بین کلیدها برقرار نبوده و مهمتر آنکه امضا متعلق به امضاکننده نیست.
\\
\\
\subsection{پروتکل زیگما}\LTRfootnote{Sigma Protocols}\label{sigma}

 پروتکل زیگما 
$\Sigma = ((P^1,P^2),V)$
، یک سیستم اثبات تعاملی است که شامل چهار قسمت به ترتیب زیر می‌باشد:
\begin{itemize}
\item 
 تعهد
\LTRfootnote{commitment}
$com = P^1(x,w)$
 توسط اثبات کننده ارائه می‌شود و به معنی آن است که اثبات‌کننده برای ادعای خود یعنی
 $x$
 ، شاهد 
 $w$
 را دراخنیار دارد.
\item 
 چالش 
$ch$
که به‌صورت  تصادفی و یکنواخت از یک دامنه‌ی مجاز
$N_{ch}$
، توسط تاییدکننده برای به چالش کشیدن ادعای مطرح‌شده توسط اثبات‌کننده انتخاب می‌شود. 
\item 
 پاسخ 
$resp = P^2(x,w,com,ch)$
 ، براساس چالش دریافتی  
$ch$
از طرف تایید‌کننده ، توسط اثبات‌کننده محاسبه می‌شود.
\item
خروجی 
$V(x,com,ch,resp)$
 توسط تاییدکننده محاسبه می‌شود و مقدار آن  صفر یا یک می‌باشد و معین آن است که  اثبات مورد پذیرش  واقع شده است یا خیر، بنابراین اگر خروجی صفر باشد به معنی رد و نپذیرفتن اثبات و خروجی یک به معنی تایید اثبات می‌باشد. 
	
\end{itemize}~
\\
\textbf{توجه.}
اگر پروتکل زیگما را به صورت خلاصه‌شده‌ی
$\Sigma = (P,V)$
در نظر بگیریم آنگاه

$P = (P^1,P^2)$
خواهد بود.
\\
\\
پروتکل زیگما علاوه بر قسمت‌های بالا که در هر سیستم اثبات دانش‌صفر‌تعاملی وجود دارد باید ویژگی‌های زیر را نیز دارا باشد :

\begin{itemize}
\item[]{\bf تمامیت }\LTRfootnote{Completeness}:
	
اگر اثبات کننده
$\mathcal{P}$
واقعا شاهد 
$w$
را برای اظهار
$x$
بداند آنگاه طبق این پروتکل ، تاییدکننده 
$\mathcal{V}$
ادعای اثبات کننده را می‌پذیرد.
	
\item[]{\bf صداقت ویژه }\LTRfootnote{Special soundness}:
	
 الگوریتم چندجمله‌ای استخراج
\LTRfootnote{polynomial time extractor}
$E_{\Sigma}$
وجود دارد که با دریافت هر جفتی از تعاملات معتبر
$(com , ch , resp)$
و
$(com , ch' , resp')$
با شرط آنکه
$ch \ne ch'$
و هر دو تعامل مورد پذیرش تاییدکننده ‌باشد، 
%	$E_{\Sigma}$
می‌تواند یک شاهد 
$w$
 که  
$(x,w) \in R $
را محاسبه کند. 
\\
\\
توجه به این نکته لازم است که در اینجا برای یک اظهار
$com$
دو چالش 
$ch$
و
$ch'$
همزمان برای آن ارسال شده و جواب‌های
$resp$
و
${resp~}'$
دریافت می‌شود که در پروتکل زیگما هیچ‌گاه این اتفاق مجاز به انجام نیست و برای هر تعهد
$com$
باید  فقط یک چالش انجام بپذیرد اما در اینجا فرض شده است اگر فرض کنیم برای هر تعهد بتوانیم دو چالش متفاوت ارسال و دو پاسخ دریافت کنیم آنگاه الگوریتمی موجود هست که باعث افشای شاهد می‌شود.
	
\item[]{\bf دانش صفر تاییدکننده صادق }\LTRfootnote{Honest-verifier zero-knowledge (HVZK)} :
	
 الگوریتم چندجمله‌ای شبیه ساز 
$S_{\Sigma}$
وجود دارد که خروجی آن
$(com,ch,resp)$
می‌باشد که نسبت به خروجی دریافت شده توسط تعاملات حقیقی بین اثبات‌کننده و تاییدکننده هیچ  نوع تمایزی وجود ندارد.
\end{itemize}
~
\\
\textbf{توجه.}
اثبات‌دانش‌صفر‌هویت  همسانی ‌مبنای گفته شده در مثال بالا
\ref{fig:zkp}
 در اصل یک پروتکل زیگما می‌باشد.
\\
\\
\subsection{سیستم اثبات غیرتعاملی }\LTRfootnote{Non-interactive Proof System}\label{non-pf}
یک سیستم اثبات غیرتعاملی شامل دو قسمت می‌باشد :
\begin{itemize}
	
\item
 اثبات کننده 
$P(x,w)$
، یک اثبات
$\pi$
برای اظهار 
$x$
(که دارای شاهد
$w$
می‌باشد) ادعا می‌کند. 

\item
تاییدکننده 
$V(x,\pi)$
اگر با اثبات
$\pi$
متقاعد به اظهار
$x$
شود، اثبات را
\textbf{تایید}
 می‌کند و درغیراینصورت آن را
\textbf{انکار}
یا رد می‌کند.
	
\end{itemize}~

یک سیستم اثبات غیرتعاملی 
$(P,V)$
شامل سه ویژگی زیر می‌باشد:
\begin{itemize}
	
\item[]{\bf تمامیت} :
	
‌اگر شاهد 
$w$
برای اظهار
$x$
واقعا وجود داشته باشد آنگاه تاییدکننده 
$V$
، اثبات
 
$\pi = P(x,w)$
را می‌پذیرد. 
	
\item[]{\bf دانش صفر}\LTRfootnote{Zero-knowledge (NIZK)} :
	
 الگوریتم چندجمله‌ای شبیه ساز 
$S$
که به یک اوراکل تصادفی دسترسی دارد، موجود است که می‌تواند اثبات‌هایی مشابه و غیرقابل تمایز با اثبات‌های تولید شده توسط اثبات کننده
$\mathcal{P}$
 را تولید(یا شبیه‌سازی) کند.
 \iffalse
  الگوریتم شبیه‌ساز به وسیله دو الگوریتم  \\
$S = (S_{init} , S_P)$
 بیان می‌شود.
	 % تعریف کامل نیست و نیاز به مطالعه بیشتر در زمینه الگوریتم های کوانتومی‌ می‌باشد.
\fi	 
\item[]{\bf شبیه‌ساز صداقت با ویژگی استخراج آنلاین }\LTRfootnote{
	Simulation-sound online-extractability }
	
 الگوریتم چندجمله‌ای استخراج
$E$
وجود دارد که توانایی تولید یک شاهد 
$w$
برای ادعای 
$x$
مطرح شده توسط اثبات‌کننده  را دارا می‌باشد.
	% تعریف کامل نیست !!!!!!!
\end{itemize}~
\\
\\
% ====================================================================================
% Unruh Construction
% ====================================================================================
\subsection{ساخت آنره}\label{unruh_constuction}

ساخت آنره ، پروتکل زیگما 
$(\Sigma)$
را به یک سیستم اثبات غیرتعاملی 
$(P_{OE}, V_{OE})$
تغییر‌شکل می‌دهد بطوریکه اگر پروتکل زیگما
$(\Sigma)$
شامل ویژگی‌های تمامیت ، صداقت ویژه و دانش صفر باشد آنگاه نتیجه یک سیستم اثبات دانش‌صفر  غیرتعاملی با ویژگی  شبیه ‌ساز صداقت با استخراج آنلاین خواهد بود.
% hspace{2mm}
\\
 فرض کنید یک پروتکل زیگما به صورت 
$\Sigma = (P_\Sigma , V_\Sigma)$
که
$P_\Sigma = (P_\Sigma^1 , P_\Sigma^2)$
داشته باشیم که 
$c$
 چالش ممکن متمایز در دامنه‌ی چالش ها 
$(N_{ch})$
داشته باشد و ‌قرار است  پروتکل به تعداد 
$t$
بار(که به پارامتر امنیتی
$\lambda$
بستگی دارد) اجرا شود. و همچنین فرض کنید اوراکل‌های تصادفی کوانتومی
$G$
و
$H$
را نیز در اختیار داریم. 
\\ 
$(P_{OE} , V_{OE})$
یک سیستم اثبات غیرتعاملی براساس پروتکل زیگما می‌باشد که 
$P_{OE}$
به عنوان اثبات‌کننده و 
$V_{OE}$
به عنوان تاییدکننده از طریق الگوریتم های 
\ref{algorithm_prover}
 و 
\ref{algorithm_verifier} 
 به دست می‌آیند.
\\
\\
لازم به ذکر است  در طرح امضای دیجیتال معرفی شده در این پایان نامه، مقادیر فرض شده در پروتکل زیگما  به صورت
$N_{ch} = \{0,1\}$
،
$c = 2$ 
 و
$t = 2\lambda $ 
می‌باشند.
\\
\\
% ==========================================================================================
% algorithm 1&2 
% ==========================================================================================
\subsubsection{الگوریتم اثبات‌کننده}\label{algorithm_prover}
\begin{enumerate}
	\item {
همان‌طور که در خط اول الگوریتم اثبات‌کننده ذکر شده است خواهان آن هستیم که تعداد
$ t\cdot c $
اثبات (از طریق پروتکل زیگما) تولید کنیم. دلیل استفاده از این مقدار به این خاطر است که طبق آنچه قبلا در پروتکل زیگما اشاره کردیم برای امنیت کامل لازم است تا پروتکل زیگما به تعداد
$t$
بار تکرار شود.
 اما مقدار 
$c$
، به این دلیل است که در پروتکل زیگما، تاییدکننده به انتخاب خود یک چالش را از میان چالش‌های مجاز(دامنه‌ی چالش‌ها)	انتخاب می‌کند ولی به دلیل آنکه در ساخت آنره هدف آن است که ارتباط با تاییدکننده حذف شود بنابراین در این سیستم تمام چالش‌ها  شبیه‌سازی می‌شود تا هیچ دانش خاصی در به‌کارگرفتن چالش در هر مرحله صورت نگیرید و اثبات کاملا تصادفی و یکنواخت باشد.
}

\item {
بنابراین برای ایجاد امنیت کامل لازم است تا به تعداد  
$t$
مرتبه رویه اثبات شبیه‌سازی شود که بدین منظور از یک حلقه‌ی تکرار استفاده می‌کنیم. 
}

\item {
در هر بار تکرار حلقه، ادعای 
$x$
 با الگوریتم 
$P^1_{\Sigma}$
 مطرح می‌شود و به عنوان یک تعهد خروجی الگوریتم در متغیر
$com_i$
ذخیره می‌گردد
}

\item {
به منظور شبیه‌سازی تمام حالت‌های ممکن برای ارسال درخواست یک چالش توسط تاییدکننده ، تمام مقادیر دامنه‌ی چالش‌ها( که 
$c$
حالت ممکن برای آن وجود دارد
)  توسط حلقه‌ی تکرار تولید می‌شود
}

\item {
در این مرحله یک چالش به صورت کاملا تصادفی و یکنواخت از دامنه‌ی چالش‌های مجاز انتخاب می‌شود و مقدار انتخاب شده از دامنه‌ی چالش‌ها حذف می‌گردد
}

\item {
براساس چالش دریافتی می‌بایست یک پاسخ از طرف تاییدکننده ارسال شود بنابراین الگوریتم
$P^2_{\Sigma}$
اجرا می‌شود و خروجی در متغیر
$resp_{i,j}$
ذخیره می‌شود
}

\item {
در این مرحله، از پاسخ هر چالش با الگوریتم
$G$
هش گرفته می‌شود و در متغیر 
$h_{i,j}$
ذخیره می‌شود. دلیل این امر آن است که مطمئن باشیم که پاسخ هر چالش بدون تغییر ذخیره شده است.
}\\
 تا پایان این مرحله به تعداد
$t \cdot c $
پاسخ داریم که البته هش شده است و غیرقابل‌تغییر می‌باشند.

\item {
مهمترین قسمت پروتکل آنره در این قسمت از الگوریتم انجام می‌پذیرد. 
از آنجا که با پروتکل آنره خواهان آن هستیم که از یک اثبات دانش‌صفر تعاملی به یک اثبات‌دانش‌صفر غیرتعاملی برسیم بنابراین با استفاده از مجموع تعهد‌ها،چالش‌ها و پاسخ‌های به هر  چالش  که توسط خود اثبات‌کننده در مراحل قبلی الگوریتم شبیه‌سازی شد به تولید چالش‌هایی می‌پردازیم که شبیه به چالش‌هایی باشد که از طرف تاییدکننده دریافت می‌شود با این ویژگی که کاملا تصادفی تولید شوند. در نتیجه برای تولید چالش‌ها از متغیرهای به‌دست آمده از مراحل قبلی الگوریتم با تابع
$H$
هش می‌گیریم و از آنجا که خروجی هش کاملا تصادفی می‌باشد بنابراین در هریک از 
$J_i$
ها مقدار یک یا صفر خواهیم داشت با این ویژگی که تابع هش
$H$
و ورودی‌های آن عمومی می‌باشند به این منظور که رشته 
$ (J_1 \parallel \cdots  \parallel J_t) $
توسط تاییدکننده قابل بررسی باشد.
}
\item {
بعد از اتمام تمام مراحل بالا، اثبات 
$\pi$
به عنوان خروجی الگوریتم اثبات‌کننده تولید می‌شود. اثبات موردنظر شامل یک چندتایی شامل تمام تعهدها(
$com_i$
)
،چالش‌ها(
$ch_{i,j}$
)
و همچنین هش‌شده‌ی پاسخ‌های اثبات‌کننده(
$h_{i,j}$
)
می‌باشدو آخرین قطعه‌ی این اثبات شامل پاسخ‌های شفاف ارائه‌شده توسط اثبات‌کننده می‌باشد با این تفاوت که چینش پاسخ‌ها براساس چینش تولید شده نمی‌باشد به عبارت دیگر پاسخ‌های 
$resp_{i,j}$
متناسب با چالش‌های ساخته شده توسط 
$J_i$
ها به دست می‌آید یعنی به جای ارسال 
$resp_{i,j}$
، الگوریتم
$resp_{i,J_i}$
را به دست آورده و آن‌ها را در اثبات
$\pi$
قرار می‌دهد.
}
	
\end{enumerate}

% ===========================================================================================
% Algorithm 1 
% ===========================================================================================
\begin{algorithm}\label{alg_prover}
	\caption{Prover : $P_{OE}$ on input $(x,w)$}
	\begin{latin}
		%\resetlatinfont
		\begin{algorithmic}[1]
			\State // Create t.c proofs and hash each response
			\For{ $ i=1 \ \textbf{to} \ t $ }
			\State $com_i \leftarrow P_{\Sigma}^{1}(x,w)$
			\For{ $j=1 \ \textbf{to} \ c $ }
			\State $ch_{i,j} \leftarrow_{R} N_{ch} \setminus \{ch_{i,1} , \cdots , ch_{i,j-1} \}$
			\State $resp_{i,j} \leftarrow P_{\Sigma}^2 (x,w,com,ch_{i,j})$
			\State $h_{i,j} \leftarrow G(resp_{i,j})$ 
			\EndFor 
			\EndFor
			
			\State // Get challenge by hashing
			\State $ J_1 \parallel \cdots \parallel j_t \leftarrow H(x(com_i)_i , (ch_{i,j})_{i,j} , (h_{i,j})_{i,j}   ) $ \Comment{Get challenge by hashing}
			
			\State // return proof
			\State \textbf{return} $\pi \leftarrow ( (com_i)_i , (ch_{i,j})_{i,j} , (h_{i,j})_{i,j} , (resp_{i,J_i})_i  )$ \Comment{return proof}
		\end{algorithmic}
	\end{latin}
\end{algorithm}

% ===========================================================================================
% ===========================================================================================
\newpage~
\\
\\
\subsubsection{الگوریتم تاییدکننده}\label{algorithm_verifier}
\begin{enumerate}
\item {
در آغاز این الگوریتم، تاییدکننده خود جدای از آن‌که چالش‌ها را دریافت کند به تولید چالش‌ها می‌پردازد به عبارت دیگر چالش موجود در پروتکل آنره به صورت تصادفی ولی با یک روش مشخص به دست می‌آید چنان‌که هم اثبات‌کننده و هم تاییدکننده می‌توانند با یک تابع مشخص(
$H$
)
به آن برسند. لازم به ذکر است که تمام ورودی‌های این تابع بوسیله اثبات‌کننده به‌عنوان اثبات (
$\pi$
)	
برای تاییدکننده فرستاده شده است.
}

\item {
برای آن‌که اثبات 
$\pi$
توسط تاییدکننده تایید شود لازم است که بررسی‌های زیر به‌تعداد ادعاهای مطرح‌شده توسط اثبات‌کننده صورت بپذیرد بنابراین از یک حلقه تکرار استفاده می‌کنیم
}

\item {
تمام چاش‌های تولید شده در الگوریتم قبلی باید نسبت به هم متفاوت باشند بنابراین بررسی می‌شود که آیا هر دو زوج متفاوت از چالش‌ها باهم متفاوت هست یا خیر
}

\item {
در این خط از الگوریتم بررسی می‌شود که آیا مقدار هش پاسخ‌ها با هش دریافتی در اثبات باهم برابر هستند یا خیر. دلیل این امر آن است که تابع
$G$
عمومی است و تاییدکننده باید از هش دریافتی مطمئن شود
}
\item {
تاییدکننده بررسی می‌کند که آیا خروجی الگوریتم 
$V_{\Sigma}$
براساس ورودی‌های متناظر با آن یک می‌شود یا خیر. ذکر این نکته لازم است به دلیل آن‌که هنگام دریافت اثبات
$\pi$
از طرف اثبات‌کننده، پاسخ‌ها با چینش متناظر با چالش‌های به دست آمده از طریق 
$J_i$
ها بود یعنی 
$resp_{i,J_i}$
ها را دریافت کردیم بنابراین برای تایید پاسخ متناظر با چالش‌ها لازم است که به‌جای
$ch_{i,j}$
از مقدار
$ch_{i,J_i}$
که متناظر با 
$resp_{i,J_i}$
می‌باشد استفاده کنیم
}

\item {
اگر تمام بررسی‌های بالا صحیح باشد آنگاه خروجی الگوریتم یک می‌باشد به این معنی که اثبات توسط تاییدکننده پذیرفته شده است
}
\end{enumerate}~
\\
\\	

% ===========================================================================================
% Algorithm 2 
% ===========================================================================================
\begin{algorithm}\label{alg_verifier}
	\caption{
		Verifier : $V_{OE}$ on input $(x,\pi) $
		where \newline
		\qquad $\pi =  ( (com_i)_i , (ch_{i,j})_{i,j} , (h_{i,j})_{i,j} , (resp_{i,J_i})_i  )$
	}
	\begin{latin}
	%\resetlatinfont
	\begin{algorithmic}[1]
		\State // Compute the challenge hash
		\For{ $ i=1 \ \textbf{to} \ t $ }
		\State $ \textbf{check} ~ ch_{i,1} , \cdots ch_{i,m} pairwise distinct $
		\State $ \textbf{check} ~ h_{i,J_i} = G(resp_i) $
		\State $ \textbf{check} ~ V_{\Sigma}(x,com_i,ch_{i,J_i} , resp_i) = 1 $
		\EndFor
		\If{ all checks succeed} 
		\textbf{return} 1
		\EndIf
		
	\end{algorithmic}
	\end{latin}
\end{algorithm}

% ===========================================================================================
% ===========================================================================================
\newpage~
\\
\\
\subsection{امضا براساس اثبات دانش صفر غیرتعاملی }\LTRfootnote{Signature from Non-interactive Zero-Knowledge Proofs}\label{sign_from_nzkp}

 هر طرح امضای دیجیتالی شامل سه الگوریتم تولیدکلید
\LTRfootnote{Key Generation Algorithm}
برای ساخت کلیدخصوصی و کلیدعمومی امضاکننده، الگوریتم امضا
\LTRfootnote{Signature Algorithm}
برای امضای پیام‌های دریافتی و همچنین الگوریتم تایید‌امضا
\LTRfootnote{Verification Signature Algorithm}
برای بررسی اعتبار امضا، می‌باشد که این الگوریتم‌ها در طرح ما به صورت زیر تعریف می‌‌شوند :
\begin{itemize}
\item{
$\bf KeyGen(\lambda)$
}
		
این الگوریتم یک پارامتر امنیتی 
$\lambda$
(تا امنیت کامل طرح برآورده شود)به عنوان ورودی گرفته و یک زوج کلید 
$(pk,sk)$
را به عنوان زوج کلیدعمومی وکلیدخصوصی تولید می‌کند وبرای تولید امضا و تایید آن مورداستفاده قرار می‌گیرد.این الگوریتم توسط امضاکننده اجرا می‌شود و عمومی نیست.
\item {
$\bf Sign(sk,m)$	
}

این الگوریتم، پیام
$m$
وکلید خصوصی
$sk$
را به عنوان ورودی گرفته و خروجی آن امضای 
$\sigma$
می‌باشد که توسط امضاکننده منتشر می‌شود. این الگوریتم نیز توسط امضاکننده اجرا می‌شود و خصوصی است.
\item{
$\bf Verify(pk,m,\sigma)$
}

این الگوریتم با داشتن کلید عمومی امضاکننده 
$\bf pk $
تایید می کند که آیا امضای دریافتی 
$\bf \sigma $
متعلق به پیام 
$\bf m $
می‌باشد یا حیر. این الگوریتم توسط هرشخصی که خواهان بررسی امضا می‌باشد قابل اجرا خواهد بود و بنابراین یک الگوریتم عمومی است.
\end{itemize}

یک طرح امضای دیجیتال، قویا تحت حمله متن انتخاب شده
%‌\LTRfootnote{chosen message attack}
 غیرقابل جعل 
\LTRfootnote{SUF-CMA}
است اگر برای هر متخاصم
$\mathcal{A}$
\LTRfootnote{Adversary}
با داشتن الگوریتم زمان چندجمله‌ای کوانتومی و دسترسی کلاسیک به اوراکل امضای 
$\bf sig : m \mapsto Sign(sk,m)$
، حتی با احتمال خیلی کم هم نتواند یک زوج پیام-امضای جدید تولید کند. در طرح ارائه شده در این پایان‌نامه قصد داریم طرح خودرا با این ویژگی تشریح کنیم لذا در ادامه مرحله‌به‌مرحله به تشریح این طرح می‌پردازیم.
\\
فرض ‌کنیم یک تابع تولید کلید 
$\bf KeyGen$
، در اختیار داریم که یک جفت کلید عمومی-خصوصی
$\bf (sk,pk)$
را تولید می‌کند و هیج الگوریتم چندجمله‌ای کوانتومی حتی با احتمال خیلی کوچک  هم نتواند از طریق کلید عمومی
$\bf pk$
، یک کلید خصوصی
$\bf sk$
معتبر (متناظر با کلید عمومی) بازیابی کند. در این صورت یک اثبات هویت می‌تواند به صورت اثبات اظهار 
$\bf x=pk$
با شاهد 
$\bf w = sk$
در نظر گرفته شود که 
$\bf (x,w) \in R$
اگر و تنها اگر
$\bf (x,w)$
یک زوج کلید معتبر در نطر گرفته شود که می‌تواند توسط تابع 
$\bf KeyGen$
تولید شده باشد.	
\\
در این صورت ، امضای دیجیتال اساسا یک اثبات دانش صفر غیرتعاملی هویت  خواهد بود. البته  در این حالت لازم است پیام موردنظر را داخل
{\bf{اثبات(امضا)}}
وارد کنیم ، این عمل را به این صورت انجام می‌دهیم که متن موردنظر را به عنوان بخشی از اظهار 
$\bf x$
درنظر می‌گیریم به عبارت دیگر اظهار جدید ما به صورت 
$\bf x = (pk,m)$
درنظر گرفته می‌شود که در این صورت رابطه 
$\bf R $
پیام را در نظر نمی‌گیرد؛ به عبارت دیگر به طور خلاصه ،
\begin{center}
$\bf ((pk,m),w) \in R$
\quad
اگر و تنها اگر
\quad
$\bf (pk,m)$
یک زوج کلید معتبر باشند	
\end{center}	
بنابراین از طریق یک اثبات دانش صفر غیرتعاملی هویت
\LTRfootnote{NIZK proof of identity} 
$ (P,V)$
، یک طرح امضای دیجیتال 
$ \mathcal{DS}$
به دست می‌آید که شامل تعاریف زیر می‌باشد:
\newline
\newline
$$ \mathcal{DS} = (KeyGen,Sign,Verify)$$
که دراین حالت الگوریتمِ امضا با الگوریتم اثبات‌کننده پروتکل زیگما شبیه‌سازی می‌شود:
$$ Sign(sk,m) = P((pk,m),sk)$$
و الگوریتم تاییدِامضا با الگوریتم تاییدکننده پروتکل زیگما شبیه‌سازی می‌شود:
$$ Verify(pk,m,\sigma = V((pk,m,\sigma)))$$
\\
\begin{theorem}
	
	اگر 
	$(P,V)$
	یک اثبات هویت 
	$NIZK$ \LTRfootnote{Non-Interactive Zero-Knowledge}
	با ویژگی‌های شبیه ‌سازی-صداقت و استخراج-آنلاین باشد آنگاه طرح امضای
	$\mathcal{DS}$
	ذکرشده در بالا یک امضای دیجیتال
	SUF-CMA
	در مدل ارواکل تصادفی کوانتومی خواهد بود.
	
\end{theorem}

\begin{proof}
	content...
\end{proof}

% ---------------------------------------------------------------------------------------------
%        اثبات خوانده شده و به صورت کامل ذکر شود
% ---------------------------------------------------------------------------------------------

\newpage
\section{امضای دیجیتال همسانی مبنا}\label{isogeny_ds}
حال که در بخش قبلی توانستیم از یک طرح اثبات‌دانش‌صفر‌هویت‌غیرقابل‌انکار یک طرح امضای دیجیتال  غیرقابل‌جعل معرفی کنیم، در این بخش خواهان پیاده‌سازی این امضا بر اساس مسئله‌ی همسانی‌ها در خم‌های بیضوی می‌باشیم.
\\
برای معرفی طرح‌امضای‌دیجیتال برا اساس همسانی‌ها لازم است الگوریتم‌هایی که در هر طرح امضایی وجود دارد را به زبان همسانی‌ها بازتعریف کنیم. بنابریان در ادامه به معرفی الگوریتم‌های تولید‌کلید،امضا و تاییدسازی می‌پردازیم. اما از آنجا که طرح ما در یک فضای‌خاصی تعریف می‌شود لازم است که ابتدا به تعریف محیطی که امضا درآن تعریف می‌شود بپردازیم پس ابتدا به عنوان تعریف محیط طرح خود، پارامترهای عمومی را تعریف می‌کنیم:
\\ 
\begin{itemize}
	\item[]{\bf پارامترهای عمومی }\LTRfootnote{Public Parameters}
	
	پارامترهای عمومی ما همان پارامترهای عمومی معرفی شده در پروتکل زیگما می‌باشد:
	\begin{itemize}
		\item {
		 عدد اول به فرم 
		$p = \ell_A^{e_A} \ell_B^{e_B} \cdot f \pm 1$
	}

		\item {
		 خم بیضوی سوپرسینگولار 
		$E$
		از مرتبه‌ی
		$(\ell_A^{e_A} \ell_B^{e_B})^2$
		در میدان 
		$\mathbb{F}_{p^2}$
	}

		\item {
		زوج نقاط 
		$(P_B,Q_B)$
		مولد زیرگروه تابی 
		$E[\ell_B^{e_B} ]$
	}
	\end{itemize}	 
	
	\item[]{\bf تولیدکلید}\LTRfootnote{Key Generation}
	
	برای تولید کلید ، یک نقطه تصادفی
$S$
از مرتبه‌ی
$\ell_A^{e_A}$	
انتخاب و همسانی
\newline
$\phi : E \rightarrow E/ \langle S \rangle $
را محاسبه می‌کنیم و زوج کلید 
$(pk,sk)$
که  
\\
$pk = \Big(E/ \langle S \rangle , \phi (P_B) , \phi (Q_B) \Big)$
و
$ sk = S $
را به عنوان خروجی نمایش می‌دهیم.
\newline
\newline
\newline
\item[]{\bf امضا}\LTRfootnote{Signing}

برای امضای پیام 
$m$
، الگوریتم امضا را به صورت زیر انجام می‌دهیم: 
$$ Sign(sk,m) = P_{OE}((pk,m),sk)$$

\item[]{\bf تاییدسازی}\LTRfootnote{Verification}

برای تایید امضای
$\sigma$
برای پیام مشخص
$m$
، الگوریتم تایید را به صورت زیر انجام می‌دهیم:
$$ Verify(pk,m,\sigma) = V_{OE}((pk,m),\sigma) $$

الگوریتم های ۳و۴و۵ به طور صریح الگوریتم‌های تولیدکلید ، امضا و تاییدسازی را بر اساس مسئله همسانی  بیان می‌کنند.
\subsection{الگوریتم تولیدکلید}\label{algorithm_keygen}
همان‌طور که در الگوریتم ۳ مشاهده می‌شود
\begin{enumerate}
	\item {
	ابتدا یک نقطه‌تصادفی 
	$S$
	ازمرتبه‌ی
	$\ell_A^{e_A}$
	انتخاب می‌کنیم.
	}

	\item {
	در قدم بعدی همسانی
	$\phi : E \rightarrow E/ \langle S \rangle$
	را از طریق فرمول ولو و با هسته
	$\langle S \rangle$
	به دست می‌آوریم
	}

	\item {
	حال خم 
	$E/ \langle S \rangle$
	و تصویر نقاط 
	$\phi{P_B}$
	و
	$\phi{Q_B}$
	را به عنوان کلیدعمومی
	$pk$
	در نظر می‌گیریم
	}

	\item {
	و همچنین کلیدخصوصی را نقطه تصادفی
	$S$
	درنظر می‌گیریم
	}

	\item {
	در پایان خروجی این الگوریتم زوج کلیدعمومی و خصوصی 
	$(pk,sk)$
	می‌باشد
	}
\end{enumerate}

\subsection{الگوریتم امضا}\label{algorithm_sign}
الگوریتم امضا با ورودی پیام
$m$
و کلیدخصوصی 
$sk$
در طرح ما در یک مرحله انجام نمی‌شود و لازم است که برای تولید خروجی الگوریتم عملیاتی بارها انجام شود بنابراین در این الگوریتم روال زیر طی خواهد شد :
\begin{enumerate}
	\item {
	همان‌طور که قبلا توضیح دادیم، الگوریتم امضای ما براساس الگوریتم اثبات‌کننده در ساخت آنره به دست می‌آید بنابراین برای امنیت کامل لازم است که الگوریتم به تعداد مشخصی تکرار شود و طبق آنچه قبلا ذکر شد لازم است که ایت تکرار به اندازه
	$2\lambda$
	باشد، بنابراین از یک حلقه تکرار استفاده می‌کنیم
	}

	\item {
	 عدد  
	$R$
	به صورت کاملا تصادفی از مرتبه‌ی
	$\ell_B^{e_B}$
	 انتخاب می‌شود
	}

	\item {
	درادامه همسانی
	$\psi$
	از طریق فرمول ولو و با زیرگروه
	$\langle R \rangle$
	به صورت
	$\psi : E \rightarrow E/ \langle R \rangle $
	محاسبه می‌شود
	}

	\item {
	سپس دو همسانی
	 $\phi'$
	 و
	 $\psi '$
	 مستقلا توسط زیرگروه‌های مشخص زیر توسط فرمول ولو محاسبه می‌شود :
	 $$ \phi' : E/ \langle R \rangle \rightarrow E/ \langle R,S \rangle $$
	 $$ \psi' :  E/ \langle S \rangle  \rightarrow E/ \langle R,S \rangle $$
	}

	\item {
	خم‌های به دست آمده از دوهمسانی 
	$\phi'$
	و
	 $\psi '$
	 را به صورت زیر نامگذاری می‌کنیم :
	 $$ (E_1,E_2) \leftarrow (E/ \langle R \rangle ,  E/ \langle R,S \rangle) $$
	}

	\item {
	همان‌طور که در ساخت آنره(برگرفته از پروتکل زیگما) مشاهده کردیم لازم است اثبات‌کننده (در اینجا امضاکننده) تعهدی را برای اثبات ارائه کند، بنابراین تعهد مطرح شده در الگوریتم امضا به صورت زیر خواهد بود :
	$$ com_i \leftarrow (E_1,E_2) $$
	}

	\item {
	برای به چالش کشیدن امضاکننده براساس تعهدی که ارائه کرده است لازم است چالشی توسط ساخت آنره تولید شود و چون دامنه‌ی چالش‌ها محدود به دو انتخاب است بنابراین چالش ما به صورت تصادفی از بین دو مقدار صفرو یک انتخاب می‌شود :
	$$ ch_{i,0} {\leftarrow}_R ~ \{0,1\} $$
	}

	\item {
	در این مرحله بدون درنظر گرفتن چالش انتخابی مرحله قبل، پاسخ‌های را براساس زیر تولید می‌کنیم. دلیل این امر این است که پاسخ‌های امضاکننده در هرمرحله ثابت ولی نسبت به چالش ارائه شده جایگشتی در ارائه آنها در مرحله‌ی بعدی صورت می‌گیرد. با این اوصاف پاسخ‌های الگوریتم به صورت زیر تعیین می‌شوند:
	$$ (resp_{i,0} , resp_{i,1}) \leftarrow ( (R , \phi(R)) , \psi(S)) $$
	}

	\item {
	در این مرحله مشخص می‌شود براساس چالش دریافتی پاسخ چه باشد. اگر بیت چالش صفر باشد پاسخ همان ترتیب بالا خواهد بود وگرنه جای پاسخ‌ها با یکدیگر عوض شده و سپس ارسال می‌شود
	}

	\item {
	در این مرحله به منظور اطمینان از ثبت درست مراحل بالا طبق الگوریتم امضا لازم است که از پاسخ‌ها با کمک تابع
	$G$
	هش گرفته شود بنابراین :
	$$ h_{i,j} \leftarrow G(resp_{i,j}) $$
	}

	\item {
	همان‌طور که در الگوریتم اثبات‌کننده مطرح شد لازم است که چالش توسط خود الگوریتم به صورت تصادفی و بدون هرگونه دخالت دانش قبلی تولید شود بنابراین 
	$2\lambda$
	چالش ممکن توسط کد زیر تولید می‌شود:
	$$ J_1 \parallel \cdots \parallel J_{2 \lambda} \leftarrow 
	   H(pk , m , (com_i)_i , (ch_{i,j})_{i,j} , (h_{i,j})_{i,j} )
    $$
    لازم به یادآوری است که تابع 
    $H$
    تابع هش می‌باشد
	}

	\item{
	خروجی الگوریتم، امضای امضاکننده (اثبات اثبات‌کننده) می‌باشد که به صورت زیر تولید می‌شود:
	$$ \sigma \leftarrow ( (com_i)_i , (ch_{i,j})_{i,j} , (h_{i,j})_{i,j} , (resp_{i,J_i})_i ) $$
و برای تاکیید بیشتر لازم به یادآوری است که پاسخ‌های
	$resp$
تولید شده در مراحل قبلی کاملا به صورت تصادفی و بدون هیچ ترتیب خاصی و وابسته به چالش‌های
	$J_i$
	در اثبات جاسازی می‌شوند
	}
\end{enumerate}

\subsection{الگوریتم تایید امضا}\label{algorithm_verify_signature}
 با داشتن کلیدعمومی
$pk$
،پیام
$m$
و امضای دریافتی 
$\sigma$
از طرف امضاکننده، هر شخصی می‌تواند بدون تعامل با امضاکننده به تایید امضا بپردازد. تاییدکننده باید طبق الگوریتم تایید مراحل زیر را انجام دهد :
\begin{enumerate}
	\item { 
  از آنجا که طرح امضای ما براساس ساخت آنره می‌باشد ودر این پروتکل تعاملی بین 
  اثبات‌کننده(امضاکننده) و تاییدکننده برقرار نیست باید راهی وجود داشته باشد تا تاییدکننده نیز به چالش‌هایی که اثبات‌کننده نسبت به آن‌ها پاسخ داده است اشراف داشته باشد بنابراین همان‌طور که در الگوریتم امضا مشاهده شد، چالش‌ها از قسمت‌هایی به‌دست می‌آید که آن قسمت‌ها توسط امضاکننده منتشر و عمومی می‌شود بنابراین تاییدکننده نیز می‌تواند خود مستقلا به تولید چالش‌ها بپردازد. این عمل نشان می‌دهد که چالش‌ها واقعا به صورت تصادفی خلق شده‌اند.
  بنابراین در اولین قدم اجرای الگوریتم، چالش‌ها مستقلا بازتولید می‌شوند تا در قدم‌های بعدی الگوریتم مورد استفاده قرار گیرد:
	$$ J_1 \parallel \cdots \parallel J_{2 \lambda} \leftarrow 
	H(pk , m , (com_i)_i , (ch_{i,j})_{i,j} , (h_{i,j})_{i,j} )
	$$
	}

	\item {
	از آنجا که برای تولید امضا
	$\pi$
	، به 
	$2\lambda$
	راند نیاز بود بنابراین برای تایید آن نیز به 
	$2\lambda$
	مرحله نیاز است که برای این امر از حلقه تکرار استفاده می‌کنیم
	}

	\item {
	چون تابع هش 
	$G$
	عمومی است پس می‌توان بررسی کرد که آیا هش پاسخ‌ها 
	$h_{i,j} $
	به عنوان بخشی از اثبات 
	$\pi$
	از پاسخ‌های 
	$resp_{i,j}$
	الگوریتم امضا به‌دست آمده است یا خیر. درنتیجه این بررسی در الگوریتم تایید مستقلا انجام می‌شود:
	$$ \textbf{check} ~ h_{i,J_i} = G(resp_{i,J_i})$$
	}

	\item {
	از آنجا که برای تولیدامضا 
	$2\lambda$
	مرحله نیاز بود برای تاییدامضا نیز باید این تعداد مرحله انجام شود. همچنین می‌دانیم در طرح خود چالش یا صفر است یا یک، درنتیجه اگر چالش صفر باشد عملیات خاصی انجام می‌شود و اگر چالش یک باشد عملیاتی متناظر با آن انجام خواهد شد.
	}
	\item {
	اگر چالش  صفر انتخاب شده باشد آنگاه عملیات زیر به ترتیب انجام می‌شود:
	\begin{itemize}
		\item {
		پاسخ
		$resp_{i,J_i}$
		به عنوان مقدار
		$(R,\phi(R))$
		انتخاب می‌شود ؟؟؟؟؟؟؟
		}
	
		\item {
		در قدم بعدی بررسی می‌شود که آیا
		$(R,\phi(R))$
		از مرتبه‌ی
		$\ell_B^{e_B}$
		می‌باشد یا خیر
		}
		\item {
		با داشتن دو خم 
		$E$
		و
		$E_1$
		و همچنین فرمول ولو بررسی می‌شود که آیا 
		$R$
		تولیدکننده‌ی هسته‌ی همسانی
		$\psi : E \rightarrow E_1$
		می‌باشد یا خیر
		}
	
		\item {
			درآخرین قسمت این مرحله بررسی می‌شود که آیا
		$\phi(R)$
		تولیدکننده هسته‌ی همسانی
		${\psi}' : E / \langle S \rangle \rightarrow E_2$
		می‌باشد یا خیر. این بررسی نیز با داشتن دو خم 
		$E / \langle S \rangle$
		و
		$E_2$
		و همچنین فرمول ولو و  الگوریتم ؟؟؟ قابل انجام می‌باشد
		
		}
	\end{itemize}		
	}

	\item {
	اگر چالش حاوی مقدار یک باشد آنگاه مراحل زیر انجام می‌شود:
	\begin{itemize}
		\item {
		پاسخ 
		$resp_{i,J_i}$
		به عنوان 
		$\psi(S)$
		درنظرگرفته می‌شود؟؟؟
		}
	
		\item {
		بررسی می‌شود که آیا
		$\psi(S)$
		از مرتبه‌ی
		$\ell_A^{e_A}$
		می‌باشد یاخیر
		}
	
		\item {
		همچنینی بررسی می‌شود که آیا 
		$\psi(S)$
		
		تولیدکننده‌ی هسته‌ی همسانی
		${\phi}' :‌E_1 \rightarrow E_2$
		می‌باشد یا خیر
		}
	\end{itemize}
	}

	\item {
	اگر در تمام بررسی‌های بالا پاسخ بلی باشد آنگاه الگوریتم یک رو به عنوان خروجی تولید می‌کند به این معنی که امضا پذیرفته شده است.
	}
\end{enumerate}
\end{itemize}

% -----------------------------------------------------------
% algorithms 3,4,5
% ------------------------------------------------------------


% =========================== algorithmic aspect =============================================

% ============================================================================================


% =========================== Security =========================================================
\section{\bf امنیت}\LTRfootnote{Security}\label{security}

امنیت سیستم های رمزنگاری همسانی مبنا بر اساس سختی مسائلی همچون دو مساله  بیان شده در زیر بنا شده است که حتی در برابر کامپیوترهای کوانتومی نیز کاملا ایمن می‌باشند. در طرح امضای دیجیتال ارائه شده در این پایان نامه ، امنیت بر اساس این دو مساله بنا شده است.\\


اگر عدد اول 
$p$
را به فرم
$\ell_A^{e_A} \ell_B^{e_B} . f \pm 1 $
در نظر بگیریم ، آنگاه یک خم بیضوی سوپرسینگولار 
$E_0$
روی میدان
$\mathbb{F}_{p^2}$
وجود دارد که زوج نقاط
$\{P_A , Q_A \}$
و
$\{ P_B , Q_B \}$
مولدهای زیرگروه های
$E_0[\ell_A^{e_A}]$
و
$E_0[\ell_B^{e_B}]$
می‌باشند. 
%همچون همسانی‌های بین خم های معمولی در بین همسانی‌های هم های سوپرسینگولار نیز مسائل محاسباتی زیر را معرفی می‌کنیم :\\
\\
\\
\textbf{ مساله همسانی سوپرسینگولار محاسباتی :‌}
\LTRfootnote{Computational Supersingular Isogeny (CSSI) problem}

فرض کنیم 
$\phi_A :‌E_0 \rightarrow E_A $
یک همسانی  با هسته 
$\langle [m_A]P_A + [n_A]Q_A \rangle $
می‌باشد که
$m_A$
و
$n_A$
نقاط تصادفی از میدان
$ (\mathbb{Z} / \ell_A^{e_A} \mathbb{Z}) $
است که هر دو همزمان عاملی از 
$\ell_A$
نمی‌باشند.
با داشتن
$E_A$
،
$\phi_A(P_B)$
و
$\phi_A(Q_B)$
 یافتن مولد هسته‌ی همسانی، یعنی
$\langle R_A \rangle  = \langle [m_A]P_A + [n_A]Q_A \rangle $
یک مسئله سخت محاسباتی در همسانی‌ها می‌باشد. به عبارت دیگر با داشتن دو خم 
$E_0$
و
$E_A$
و همسانی بین آنها یعنی
$\phi_{A}$
و همچنین نقاط کمکی گفته شده در بالا نمی‌توان زیرگروهی که از طریق فرمول ولو امکان‌پذیر است را به دست آورد. این مسئله به مسئله‌ی 
$CSSI$
شناخته می‌شود.
\\
\\
\textbf{توجه.}
ذکر این نکته لازم است که با داشتن مولد
$R_A = [m_A]P_A + [n_A]Q_A$
، یافتن نقاط
$m_A$
و
$n_A$
به سادگی توسط لگاریتم گسسته توسیع‌یافته
\LTRfootnote{extended discrete logarithms}
 با این فرض که خم 
$E$
هموار باشد، امکان‌پذیر است.
\cite{eDS}
\\
\\
\textbf{ مسئله ساخت خم سوپرسینگولار تصمیم‌پذیر : }
 \LTRfootnote{Decisional Supersingular Product (DSSP problem)}

فرض کنیم
$\phi : E_0 \rightarrow E_3$
یک همسانی با مرتبه 
$\ell_A^{e_A}$
باشد. با داشتن
$(E_1 , E_2 , {\phi}' )$
 ساده سازی شده با احتمال 
 $1/2$
 از طریق دو توزیع زیر ، فهمیدن اینکه کدام رخ می‌دهد یک مسپله سخت می‌باشد :
 \begin{itemize}
 	
 	\item 
 	
 	\item 
 	
 \end{itemize}
 


\subsection{\bf امنیت اثبات دانش صفر}\label{zkp_security}
\LTRfootnote{Security of the Zero-Knowledge Proof}


 در 
$[12,S 6.2]$
اثبات شده است که طرح اثبات دانش صفر هویت همسانی مبنای معرفی شده در قسمت 
\ref{ZKPOI}
دارای ویژگی‌های تمامیت ، صداقت ویژه و دانش صفر تاییدکننده صادق می‌باشد اگر فرض کنیم که مسائل 
$CSSI$
و
$DSSP$
مسائلی سخت می‌باشند.با این وجود برای امنیت کامل ، ساخت آنره باید دارای ویژگی صداقت ویژه باشد.\\

\textbf{قضیه ۳ .}

اثبات دانش صفر هویت همسانی مبنا ، ویژگی‌های تمامیت ، صداقت ویژه و دانش صفر تاییدکننده صادق را دارا می‌باشد.

اثبات. در این قسمت تنها به اثبات ویژگی صداقت خاص می‌پردازیم.فرض کنید دو رونوشت معتبر 
$(com,0,resp_0)$
و
$(com,1,resp_1)$
که 
$(com = (E_1,E_2))$
را دریافت کرده ایم. پس  می‌توانیم از
$resp_0 = (R,\phi(R))$
استفاده کنیم تا همسانی
$\psi : E \rightarrow E/ \langle R \rangle $
را محاسبه کنیم. از آنجا که 
$resp_1 = \psi(S)$
یک مولد هسته 
${\psi}'$
می‌باشد ، بنابراین می‌توانیم دوگان همسانی یعنی
${\psi}' : E/ \langle R \rangle \rightarrow E $
را به دست آوریم و 
${\psi}' (resp_1)$
را به عنوان مولد
$\langle S \rangle $
به دست آوریم.

% ==============================================================================================
\begin{figure}[H]
	\begin{center}
		
		\begin{tikzcd}
			E \arrow[r, dashrightarrow ,"\phi"] \arrow[d, "\psi"] & E/ \langle S \rangle \arrow[d, "{\psi}' "] \\
			E/ \langle R \rangle \arrow[r, "{\phi}' "] & E/\langle R,S \rangle
		\end{tikzcd}
		
		\caption{
			اگر
			$\psi$
			و
			${\phi}'$    
			هر دو همزمان معلوم باشند آنگاه می‌توان زیرگروه مخفی 
			$\langle S \rangle$
			را به دست آوریم.
		}
		\label{}
		
	\end{center}
\end{figure}
% ==============================================================================================

\subsection{امنیت امضا}\label{sign_security}






% ======================================================================
% Undeniable Signature
% ======================================================================


% ======================================================================
% Undeniable Blind Signature
% ======================================================================





































% ======================================================================
% Refrences
% ======================================================================
\newpage
\setLTRbibitems
% \resetlatinfont
\bibliographystyle{plain}
\bibliography{ref.bib}
	
\end{document}


\begin{itemize}
	
	\item[] {}
	\begin{flalign}
	i=0 \Rightarrow \quad 
	E_1 = E_0 / \langle \ell^{4}R_0 \rangle , \quad 
	\phi_0 : E_0 \rightarrow E_1 , \quad 
	R_1 = \phi_0(R_0)
	\end{flalign}
	
	
	\item[] {}
	\begin{flalign}
	i=1 \Rightarrow \quad 
	E_2 = E_1 / \langle \ell^{3}R_1 \rangle , \quad 
	\phi_1 : E_1 \rightarrow E_2 , \quad 
	R_2 = \phi_1(R_1)
	R_2 = \phi_1(\phi_0(R_0))
	\end{flalign}
	
	
	
	
\end{itemize}



% triangle diagram
\begin{tikzcd}[row sep=3em,column sep=3em]
	x_1(k+1) \arrow[d,swap,"x_1(k)"] & \\
	x_2(k+1) \arrow[d,swap,"x_2(k)"] &
	x_4(k+1)
	\arrow[lu,swap,"x_1(k)"]
	\arrow[l,swap,"x_2(k)"]
	\arrow[l,loop right,"x_4(k)"]
	\arrow[dl,shift right]
	\\
	x_3(k+1) \arrow[ru,shift right,swap,"x_3(k)"]
\end{tikzcd}


