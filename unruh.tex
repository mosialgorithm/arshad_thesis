\section{ساخت آنره}\LTRfootnote{Unruh's Construction}\label{unruh}

برای ساخت یک سیستم امضای دیجیتال برپایه‌ی پروتکل اثبات‌دانش‌صفر معرفی شده در بخش قبل لازم است در پروتکل تغییراتی صورت گیرد. به عبارت دیگر چنان‌که در توضیحات بخش قبلی ملاحظه شد در پروتکل اثبات‌دانش‌صفر نیاز است که بین اثبات‌کننده و تاییدکننده یک تعامل دوسویه برقرار باشد یعنی هنگامی که پگی قصد دارد تا دانشی را به ویکتور اثبات کند لازم است که به چالش‌هایی که از طرف ویکتور می‌آید پاسخی مناسب داده شود  اما همان‌طور که در امضای دیجیتال مشاهده شد برای اثبات یک دانش (هویت امضاکننده) لزومی به ارتباط دوسویه بین اثبات‌کننده و تاییدکننده نمی‌باشد به عبارت دیگر برای آنکه تاییدکننده قانع شود که امضا(اثبات) از طرف امضاکننده است لزومی ندارد تا با امضاکننده در ارتباط باشد و تنها کافی است با کلیدعمومی منتشر شده توسط امضاکننده به بررسی و تایید امضا بپردازد. 
\\
برای آن که بتوانیم از طریق پروتکل اثبات دانش صفر هویت به امضای دیجیتال برسیم لازم است طرح اولیه خود که به سیستم اثبات تعاملی 
\LTRfootnote{Interactive Proof System}
معروف است را به یک سیستم اثبات غیرتعاملی
\LTRfootnote{Non-interactive Proof System}
 تبدیل کنیم. اولین بار فیات و شمیر طرحی با نام خود ارائه کردند
\cite{fiat@prove}
که یک سیستم اثبات دانش صفر تعاملی را به یک سیستم اثبات دانش صفر غیرتعاملی تبدیل می‌کرد ولی به دلیل آن که این طرح در برابر حملات کوانتومی ایمن نبود، اخیرا آنره در
\cite{unruh}
سیستمی  جدید را معرفی کرده است که برخلاف طرح فیات-شمیر در برابر حملات کوانتومی نیز ایمن می باشد. بنابراین در ادامه به معرفی طرح ارائه شده توسط آنره می‌پردازیم که یک سیستم اثبات تعاملی با ویژگی‌های خاص به نام پروتکل زیگما را به یک سیستم اثبات دانش صفر غیرتعاملی تبدیل می‌کند که برای ساخت طرح امضای دیجیتالی مقاوم کوانتومی خود از این طرح سود می‌بریم.
% comment -------------------------------------------------------------
\iffalse
یک سیستم اثبات دانش صفر تعاملی را به سیستم اثبات دانش صفر غیرتعاملی متناظر با آن انتقال می‌دهد. این ساخت ، ویژگی استخراج آنلاین
\LTRfootnote{online extractability}
را که اجازه می‌دهد شاهد(کلید خصوصی) را از یک متخاصم موفق بدون چرخش
\LTRfootnote{rewinding}
استخراج کنیم ، را دارا می‌باشد.
\fi
% مطالب بیشتر مقاله باید تحقیق شود
% comment -----------------------------------------------------------------------------------
\iffalse
در ابتدای امر این فرص را داریم که تمام بخش های این پروتکل به یک اوراکل تصادفی کوانتومی 
\LTRfootnote{quantum random oracle}
$H$
دسترسی دارند.
% ادامه باید بررسی شود !!!
\fi
\\
\\
در یک سیستم اثبات ، اثبات کننده 
$\mathcal{P}$
خواهان آن است تا اظهار 
$x$
را برای تاییدکننده 
$\mathcal{V}$
اثبات کند با این ویژگی که برای متقاعد کردن تاییدکننده برای اظهار
$x$
، شاهد 
$w$
را برای ادعای خود در اختیار دارد. در هر پروتکل اثبات یک رابطه باینری به نام 
$R$
وجود دارد، به این معنی که اگر اظهار
\LTRfootnote{Statement}
$x$
ادعا ‌شود آنگاه باید شاهدی
\LTRfootnote{Witness}
به نام 
$w$
برای آن موجود باشد که در این صورت آن را به صورت 
$(x,w) \in R $
نمایش خواهیم داد. به طور مثال در امضای دیجیتال اگر کلید عمومی 
$v$
برای امضای
$S$
ادعا شود آنگاه کلیدخصوصی
$s$
به عنوان شاهدی برای کلیدعمومی می‌باشد که رابطه‌ی این دو به صورت زیر تعریف می‌شود:
$$(v,s) \in R ~ ; \quad R :\{ ~ ‌sv \equiv 1  \mod ( (p-1)(q-1) )  \} $$
به عبارت دیگر اگر کلید عمومی (ادعا) منتشر شده با کلیدخصوصی(شاهد)  امضاکننده واقعا رابطه‌ای داشته باشند آنگاه برای هر چالشی که توسط تاییدکننده (در اینجا چالش ، پیام 
$m$
می‌باشد) برای امضاکننده (اثبات‌کننده)ارسال می‌شود، باید بعداز دریافت امضای پیام بتوانیم با کلیدعمومی به پیام ارسال شده برسیم . بنابراین زمانی ادعای امضاکننده مبنی بر داشتن شاهد یا کلیدخصوصی محرز می‌شود که بتوانیم با کلیدعمومی منتشر شده توسط وی به پیام برسیم ،در غیراینصورت ادعا موردقبول واقع نمی‌شود و درنتیجه آشکار می‌شود که رابطه‌ای بین کلیدها برقرار نبوده و مهمتر آنکه امضا متعلق به امضاکننده نیست.
\\
\\
\subsection{پروتکل زیگما}\LTRfootnote{Sigma Protocols}\label{sigma}

 پروتکل زیگما 
$\Sigma = ((P^1,P^2),V)$
، یک سیستم اثبات تعاملی است که شامل چهار قسمت به ترتیب زیر می‌باشد:
\begin{itemize}
\item 
 تعهد
\LTRfootnote{commitment}
$com = P^1(x,w)$
 توسط اثبات کننده ارائه می‌شود و به معنی آن است که اثبات‌کننده برای ادعای خود یعنی
 $x$
 ، شاهد 
 $w$
 را دراخنیار دارد.
\item 
 چالش 
$ch$
که به‌صورت  تصادفی و یکنواخت از یک دامنه‌ی مجاز
$N_{ch}$
، توسط تاییدکننده برای به چالش کشیدن ادعای مطرح‌شده توسط اثبات‌کننده انتخاب می‌شود. 
\item 
 پاسخ 
$resp = P^2(x,w,com,ch)$
 ، براساس چالش دریافتی  
$ch$
از طرف تایید‌کننده ، توسط اثبات‌کننده محاسبه می‌شود.
\item
خروجی 
$V(x,com,ch,resp)$
 توسط تاییدکننده محاسبه می‌شود و مقدار آن  صفر یا یک می‌باشد و معین آن است که  اثبات مورد پذیرش  واقع شده است یا خیر، بنابراین اگر خروجی صفر باشد به معنی رد و نپذیرفتن اثبات و خروجی یک به معنی تایید اثبات می‌باشد. 
	
\end{itemize}~
\\
\textbf{توجه.}
اگر پروتکل زیگما را به صورت خلاصه‌شده‌ی
$\Sigma = (P,V)$
در نظر بگیریم آنگاه

$P = (P^1,P^2)$
خواهد بود.
\\
\\
پروتکل زیگما علاوه بر قسمت‌های بالا که در هر سیستم اثبات دانش‌صفر‌تعاملی وجود دارد باید ویژگی‌های زیر را نیز دارا باشد :

\begin{itemize}
\item[]{\bf تمامیت }\LTRfootnote{Completeness}:
	
اگر اثبات کننده
$\mathcal{P}$
واقعا شاهد 
$w$
را برای اظهار
$x$
بداند آنگاه طبق این پروتکل ، تاییدکننده 
$\mathcal{V}$
ادعای اثبات کننده را می‌پذیرد.
	
\item[]{\bf صداقت ویژه }\LTRfootnote{Special soundness}:
	
 الگوریتم چندجمله‌ای استخراج
\LTRfootnote{polynomial time extractor}
$E_{\Sigma}$
وجود دارد که با دریافت هر جفتی از تعاملات معتبر
$(com , ch , resp)$
و
$(com , ch' , resp')$
با شرط آنکه
$ch \ne ch'$
و هر دو تعامل مورد پذیرش تاییدکننده ‌باشد، 
%	$E_{\Sigma}$
می‌تواند یک شاهد 
$w$
 که  
$(x,w) \in R $
را محاسبه کند. 
\\
\\
توجه به این نکته لازم است که در اینجا برای یک اظهار
$com$
دو چالش 
$ch$
و
$ch'$
همزمان برای آن ارسال شده و جواب‌های
$resp$
و
${resp~}'$
دریافت می‌شود که در پروتکل زیگما هیچ‌گاه این اتفاق مجاز به انجام نیست و برای هر تعهد
$com$
باید  فقط یک چالش انجام بپذیرد اما در اینجا فرض شده است اگر فرض کنیم برای هر تعهد بتوانیم دو چالش متفاوت ارسال و دو پاسخ دریافت کنیم آنگاه الگوریتمی موجود هست که باعث افشای شاهد می‌شود.
	
\item[]{\bf دانش صفر تاییدکننده صادق }\LTRfootnote{Honest-verifier zero-knowledge (HVZK)} :
	
 الگوریتم چندجمله‌ای شبیه ساز 
$S_{\Sigma}$
وجود دارد که خروجی آن
$(com,ch,resp)$
می‌باشد که نسبت به خروجی دریافت شده توسط تعاملات حقیقی بین اثبات‌کننده و تاییدکننده هیچ  نوع تمایزی وجود ندارد.
\end{itemize}
~
\\
\textbf{توجه.}
اثبات‌دانش‌صفر‌هویت  همسانی ‌مبنای گفته شده در مثال بالا
\ref{fig:zkp}
 در اصل یک پروتکل زیگما می‌باشد.
\\
\\
\subsection{سیستم اثبات غیرتعاملی }\LTRfootnote{Non-interactive Proof System}\label{non-pf}
یک سیستم اثبات غیرتعاملی شامل دو قسمت می‌باشد :
\begin{itemize}
	
\item
 اثبات کننده 
$P(x,w)$
، یک اثبات
$\pi$
برای اظهار 
$x$
(که دارای شاهد
$w$
می‌باشد) ادعا می‌کند. 

\item
تاییدکننده 
$V(x,\pi)$
اگر با اثبات
$\pi$
متقاعد به اظهار
$x$
شود، اثبات را
\textbf{تایید}
 می‌کند و درغیراینصورت آن را
\textbf{انکار}
یا رد می‌کند.
	
\end{itemize}~

یک سیستم اثبات غیرتعاملی 
$(P,V)$
شامل سه ویژگی زیر می‌باشد:
\begin{itemize}
	
\item[]{\bf تمامیت} :
	
‌اگر شاهد 
$w$
برای اظهار
$x$
واقعا وجود داشته باشد آنگاه تاییدکننده 
$V$
، اثبات
 
$\pi = P(x,w)$
را می‌پذیرد. 
	
\item[]{\bf دانش صفر}\LTRfootnote{Zero-knowledge (NIZK)} :
	
 الگوریتم چندجمله‌ای شبیه ساز 
$S$
که به یک اوراکل تصادفی دسترسی دارد، موجود است که می‌تواند اثبات‌هایی مشابه و غیرقابل تمایز با اثبات‌های تولید شده توسط اثبات کننده
$\mathcal{P}$
 را تولید(یا شبیه‌سازی) کند.
 \iffalse
  الگوریتم شبیه‌ساز به وسیله دو الگوریتم  \\
$S = (S_{init} , S_P)$
 بیان می‌شود.
	 % تعریف کامل نیست و نیاز به مطالعه بیشتر در زمینه الگوریتم های کوانتومی‌ می‌باشد.
\fi	 
\item[]{\bf شبیه‌ساز صداقت با ویژگی استخراج آنلاین }\LTRfootnote{
	Simulation-sound online-extractability }
	
 الگوریتم چندجمله‌ای استخراج
$E$
وجود دارد که توانایی تولید یک شاهد 
$w$
برای ادعای 
$x$
مطرح شده توسط اثبات‌کننده  را دارا می‌باشد.
	% تعریف کامل نیست !!!!!!!
\end{itemize}~
\\
\\
% ====================================================================================
% Unruh Construction
% ====================================================================================
\subsection{ساخت آنره}\label{unruh_constuction}

ساخت آنره ، پروتکل زیگما 
$(\Sigma)$
را به یک سیستم اثبات غیرتعاملی 
$(P_{OE}, V_{OE})$
تغییر‌شکل می‌دهد بطوریکه اگر پروتکل زیگما
$(\Sigma)$
شامل ویژگی‌های تمامیت ، صداقت ویژه و دانش صفر باشد آنگاه نتیجه یک سیستم اثبات دانش‌صفر  غیرتعاملی با ویژگی  شبیه ‌ساز صداقت با استخراج آنلاین خواهد بود.
% hspace{2mm}
\\
 فرض کنید یک پروتکل زیگما به صورت 
$\Sigma = (P_\Sigma , V_\Sigma)$
که
$P_\Sigma = (P_\Sigma^1 , P_\Sigma^2)$
داشته باشیم که 
$c$
 چالش ممکن متمایز در دامنه‌ی چالش ها 
$(N_{ch})$
داشته باشد و ‌قرار است  پروتکل به تعداد 
$t$
بار(که به پارامتر امنیتی
$\lambda$
بستگی دارد) اجرا شود. و همچنین فرض کنید اوراکل‌های تصادفی کوانتومی
$G$
و
$H$
را نیز در اختیار داریم. 
\\ 
$(P_{OE} , V_{OE})$
یک سیستم اثبات غیرتعاملی براساس پروتکل زیگما می‌باشد که 
$P_{OE}$
به عنوان اثبات‌کننده و 
$V_{OE}$
به عنوان تاییدکننده از طریق الگوریتم های 
\ref{algorithm_prover}
 و 
\ref{algorithm_verifier} 
 به دست می‌آیند.
\\
\\
لازم به ذکر است  در طرح امضای دیجیتال معرفی شده در این پایان نامه، مقادیر فرض شده در پروتکل زیگما  به صورت
$N_{ch} = \{0,1\}$
،
$c = 2$ 
 و
$t = 2\lambda $ 
می‌باشند.
\\
\\
% ==========================================================================================
% algorithm 1&2 
% ==========================================================================================
\subsubsection{الگوریتم اثبات‌کننده}\label{algorithm_prover}
\begin{enumerate}
	\item {
همان‌طور که در خط اول الگوریتم اثبات‌کننده ذکر شده است خواهان آن هستیم که تعداد
$ t\cdot c $
اثبات (از طریق پروتکل زیگما) تولید کنیم. دلیل استفاده از این مقدار به این خاطر است که طبق آنچه قبلا در پروتکل زیگما اشاره کردیم برای امنیت کامل لازم است تا پروتکل زیگما به تعداد
$t$
بار تکرار شود.
 اما مقدار 
$c$
، به این دلیل است که در پروتکل زیگما، تاییدکننده به انتخاب خود یک چالش را از میان چالش‌های مجاز(دامنه‌ی چالش‌ها)	انتخاب می‌کند ولی به دلیل آنکه در ساخت آنره هدف آن است که ارتباط با تاییدکننده حذف شود بنابراین در این سیستم تمام چالش‌ها  شبیه‌سازی می‌شود تا هیچ دانش خاصی در به‌کارگرفتن چالش در هر مرحله صورت نگیرید و اثبات کاملا تصادفی و یکنواخت باشد.
}

\item {
بنابراین برای ایجاد امنیت کامل لازم است تا به تعداد  
$t$
مرتبه رویه اثبات شبیه‌سازی شود که بدین منظور از یک حلقه‌ی تکرار استفاده می‌کنیم. 
}

\item {
در هر بار تکرار حلقه، ادعای 
$x$
 با الگوریتم 
$P^1_{\Sigma}$
 مطرح می‌شود و به عنوان یک تعهد خروجی الگوریتم در متغیر
$com_i$
ذخیره می‌گردد
}

\item {
به منظور شبیه‌سازی تمام حالت‌های ممکن برای ارسال درخواست یک چالش توسط تاییدکننده ، تمام مقادیر دامنه‌ی چالش‌ها( که 
$c$
حالت ممکن برای آن وجود دارد
)  توسط حلقه‌ی تکرار تولید می‌شود
}

\item {
در این مرحله یک چالش به صورت کاملا تصادفی و یکنواخت از دامنه‌ی چالش‌های مجاز انتخاب می‌شود و مقدار انتخاب شده از دامنه‌ی چالش‌ها حذف می‌گردد
}

\item {
براساس چالش دریافتی می‌بایست یک پاسخ از طرف تاییدکننده ارسال شود بنابراین الگوریتم
$P^2_{\Sigma}$
اجرا می‌شود و خروجی در متغیر
$resp_{i,j}$
ذخیره می‌شود
}

\item {
در این مرحله، از پاسخ هر چالش با الگوریتم
$G$
هش گرفته می‌شود و در متغیر 
$h_{i,j}$
ذخیره می‌شود. دلیل این امر آن است که مطمئن باشیم که پاسخ هر چالش بدون تغییر ذخیره شده است.
}\\
 تا پایان این مرحله به تعداد
$t \cdot c $
پاسخ داریم که البته هش شده است و غیرقابل‌تغییر می‌باشند.

\item {
مهمترین قسمت پروتکل آنره در این قسمت از الگوریتم انجام می‌پذیرد. 
از آنجا که با پروتکل آنره خواهان آن هستیم که از یک اثبات دانش‌صفر تعاملی به یک اثبات‌دانش‌صفر غیرتعاملی برسیم بنابراین با استفاده از مجموع تعهد‌ها،چالش‌ها و پاسخ‌های به هر  چالش  که توسط خود اثبات‌کننده در مراحل قبلی الگوریتم شبیه‌سازی شد به تولید چالش‌هایی می‌پردازیم که شبیه به چالش‌هایی باشد که از طرف تاییدکننده دریافت می‌شود با این ویژگی که کاملا تصادفی تولید شوند. در نتیجه برای تولید چالش‌ها از متغیرهای به‌دست آمده از مراحل قبلی الگوریتم با تابع
$H$
هش می‌گیریم و از آنجا که خروجی هش کاملا تصادفی می‌باشد بنابراین در هریک از 
$J_i$
ها مقدار یک یا صفر خواهیم داشت با این ویژگی که تابع هش
$H$
و ورودی‌های آن عمومی می‌باشند به این منظور که رشته 
$ (J_1 \parallel \cdots  \parallel J_t) $
توسط تاییدکننده قابل بررسی باشد.
}
\item {
بعد از اتمام تمام مراحل بالا، اثبات 
$\pi$
به عنوان خروجی الگوریتم اثبات‌کننده تولید می‌شود. اثبات موردنظر شامل یک چندتایی شامل تمام تعهدها(
$com_i$
)
،چالش‌ها(
$ch_{i,j}$
)
و همچنین هش‌شده‌ی پاسخ‌های اثبات‌کننده(
$h_{i,j}$
)
می‌باشدو آخرین قطعه‌ی این اثبات شامل پاسخ‌های شفاف ارائه‌شده توسط اثبات‌کننده می‌باشد با این تفاوت که چینش پاسخ‌ها براساس چینش تولید شده نمی‌باشد به عبارت دیگر پاسخ‌های 
$resp_{i,j}$
متناسب با چالش‌های ساخته شده توسط 
$J_i$
ها به دست می‌آید یعنی به جای ارسال 
$resp_{i,j}$
، الگوریتم
$resp_{i,J_i}$
را به دست آورده و آن‌ها را در اثبات
$\pi$
قرار می‌دهد.
}
	
\end{enumerate}

% ===========================================================================================
% Algorithm 1 
% ===========================================================================================
\begin{algorithm}\label{alg_prover}
	\caption{Prover : $P_{OE}$ on input $(x,w)$}
	\begin{latin}
		%\resetlatinfont
		\begin{algorithmic}[1]
			\State // Create t.c proofs and hash each response
			\For{ $ i=1 \ \textbf{to} \ t $ }
			\State $com_i \leftarrow P_{\Sigma}^{1}(x,w)$
			\For{ $j=1 \ \textbf{to} \ c $ }
			\State $ch_{i,j} \leftarrow_{R} N_{ch} \setminus \{ch_{i,1} , \cdots , ch_{i,j-1} \}$
			\State $resp_{i,j} \leftarrow P_{\Sigma}^2 (x,w,com,ch_{i,j})$
			\State $h_{i,j} \leftarrow G(resp_{i,j})$ 
			\EndFor 
			\EndFor
			
			\State // Get challenge by hashing
			\State $ J_1 \parallel \cdots \parallel j_t \leftarrow H(x(com_i)_i , (ch_{i,j})_{i,j} , (h_{i,j})_{i,j}   ) $ \Comment{Get challenge by hashing}
			
			\State // return proof
			\State \textbf{return} $\pi \leftarrow ( (com_i)_i , (ch_{i,j})_{i,j} , (h_{i,j})_{i,j} , (resp_{i,J_i})_i  )$ \Comment{return proof}
		\end{algorithmic}
	\end{latin}
\end{algorithm}

% ===========================================================================================
% ===========================================================================================
\newpage~
\\
\\
\subsubsection{الگوریتم تاییدکننده}\label{algorithm_verifier}
\begin{enumerate}
\item {
در آغاز این الگوریتم، تاییدکننده خود جدای از آن‌که چالش‌ها را دریافت کند به تولید چالش‌ها می‌پردازد به عبارت دیگر چالش موجود در پروتکل آنره به صورت تصادفی ولی با یک روش مشخص به دست می‌آید چنان‌که هم اثبات‌کننده و هم تاییدکننده می‌توانند با یک تابع مشخص(
$H$
)
به آن برسند. لازم به ذکر است که تمام ورودی‌های این تابع بوسیله اثبات‌کننده به‌عنوان اثبات (
$\pi$
)	
برای تاییدکننده فرستاده شده است.
}

\item {
برای آن‌که اثبات 
$\pi$
توسط تاییدکننده تایید شود لازم است که بررسی‌های زیر به‌تعداد ادعاهای مطرح‌شده توسط اثبات‌کننده صورت بپذیرد بنابراین از یک حلقه تکرار استفاده می‌کنیم
}

\item {
تمام چاش‌های تولید شده در الگوریتم قبلی باید نسبت به هم متفاوت باشند بنابراین بررسی می‌شود که آیا هر دو زوج متفاوت از چالش‌ها باهم متفاوت هست یا خیر
}

\item {
در این خط از الگوریتم بررسی می‌شود که آیا مقدار هش پاسخ‌ها با هش دریافتی در اثبات باهم برابر هستند یا خیر. دلیل این امر آن است که تابع
$G$
عمومی است و تاییدکننده باید از هش دریافتی مطمئن شود
}
\item {
تاییدکننده بررسی می‌کند که آیا خروجی الگوریتم 
$V_{\Sigma}$
براساس ورودی‌های متناظر با آن یک می‌شود یا خیر. ذکر این نکته لازم است به دلیل آن‌که هنگام دریافت اثبات
$\pi$
از طرف اثبات‌کننده، پاسخ‌ها با چینش متناظر با چالش‌های به دست آمده از طریق 
$J_i$
ها بود یعنی 
$resp_{i,J_i}$
ها را دریافت کردیم بنابراین برای تایید پاسخ متناظر با چالش‌ها لازم است که به‌جای
$ch_{i,j}$
از مقدار
$ch_{i,J_i}$
که متناظر با 
$resp_{i,J_i}$
می‌باشد استفاده کنیم
}

\item {
اگر تمام بررسی‌های بالا صحیح باشد آنگاه خروجی الگوریتم یک می‌باشد به این معنی که اثبات توسط تاییدکننده پذیرفته شده است
}
\end{enumerate}~
\\
\\	

% ===========================================================================================
% Algorithm 2 
% ===========================================================================================
\begin{algorithm}\label{alg_verifier}
	\caption{
		Verifier : $V_{OE}$ on input $(x,\pi) $
		where \newline
		\qquad $\pi =  ( (com_i)_i , (ch_{i,j})_{i,j} , (h_{i,j})_{i,j} , (resp_{i,J_i})_i  )$
	}
	\begin{latin}
	%\resetlatinfont
	\begin{algorithmic}[1]
		\State // Compute the challenge hash
		\For{ $ i=1 \ \textbf{to} \ t $ }
		\State $ \textbf{check} ~ ch_{i,1} , \cdots ch_{i,m} pairwise distinct $
		\State $ \textbf{check} ~ h_{i,J_i} = G(resp_i) $
		\State $ \textbf{check} ~ V_{\Sigma}(x,com_i,ch_{i,J_i} , resp_i) = 1 $
		\EndFor
		\If{ all checks succeed} 
		\textbf{return} 1
		\EndIf
		
	\end{algorithmic}
	\end{latin}
\end{algorithm}