
\section{جنبه‌های الگوریتمی}\label{algorithm_aspect}

\subsection{ تولید پارامترها}\label{parameter_generate}

 اعداد اولی که در طرح خود استفاده می‌کنیم به فرم 
$p = \ell_A^{e_A} \ell_B^{e_B} \cdot f \pm 1$
می باشند. دلیل این امر آن است که برای تامین امنیت طرح خود لازم است تا ابتدا اعداد اول ثابت  
$\ell_A$
و
$\ell_B$
را به‌صورت مجزا از عدد اول
$p$
، با ویژگی 
$\ell_A^{e_A} \approx \ell_B^{e_B}$ 
(به این معنی که از نظر بیتی هم اندازه هستند)
انتخاب کنیم. مطمئنا با ضرب مقادیر 
$\ell_A^{e_A}$
و
$\ell_B^{e_B}$
عدد اولی خاصل نخواهد شد، در بهترین حالت با اضافه یا کم کردن مقدار یک به این حاصلضرب می‌توان به یک عدد اول رسید و اگر نتیجه حاصل نشد می‌توانیم مقدار یک را با مضربی از 
$ \ell_A^{e_A} \ell_B^{e_B} $
جمع یا تفریق کنیم. این مضرب در فرم بالا همان مقدار متغیر
$f$
می‌باشد. بنابراین عدد اول استفاده شده در طرح ما به‌یکی از فرم‌های زیر خواهد بود: 
\begin{center}
	$p = \ell_A^{e_A} \ell_B^{e_B} \cdot f - 1$~
	\text{یا}~
	$p = \ell_A^{e_A} \ell_B^{e_B} \cdot f + 1$
\end{center}

بروکر در
\cite{broker}
نشان داده است برای هر عدد اول 
$p = \ell_A^{e_A} \ell_B^{e_B} \cdot f \pm 1$
، می‌توان به راحتی یک خم بیضوی سوپرسینگولار 
$E$
روی میدان
$\mathbb{F}_{p^2}$
با مرتبه 
$({p \mp 1})^2 = (\ell_A^{e_A} \ell_B^{e_B} \cdot f)^2$
به دست آورد. دلیل این امر هم آن است که اگر
$E$
یک خم بیضوی روی میدان 
$\mathbb{F}_p$
باشد، آنگاه 
$\mathbb{F}_p$
-نقاط روی خم به شکل زیر می‌باشد:
$$ E(\mathbb{F}_p) = \{ (x,y) \in \mathbb{F}_p \times \mathbb{F}_p ~ | ~ y^2 = x^3+Ax+B \} \cup \{ \infty \}$$
که نتیجه می‌شود که :
$$ E(\mathbb{F}_p) \subseteq (\mathbb{F}_p \times \mathbb{F}_p) \cup \{ \infty \} $$
و چون مجموعه‌ی سمت راست متناهی( از مرتبه‌ی 
$p^2 + 1 $)
 است لذا مجموعه‌ی سمت چپ یعنی 
$E(\mathbb{F}_p)$
نیز متناهی است. بنابراین :
$$ \# E(\mathbb{F}_p) \leq p^2+1 $$
حال اگر یک تغییر کوچک به معادله‌ی بالا اعمال کنیم، خواهیم داشت:
$$ \# E(\mathbb{F}_p) - 1 \leq p^2 $$
حال، اگر 
$$
p = \ell_A^{e_A} \ell_B^{e_B} \cdot f + 1
~~ \text{یا} ~~
p = \ell_A^{e_A} \ell_B^{e_B} \cdot f - 1
$$
آنگاه
$$
p^2 = (\ell_A^{e_A} \ell_B^{e_B} \cdot f)^2 + 2 (\ell_A^{e_A} \ell_B^{e_B} \cdot f) + 1
~~ \text{یا} ~~
p^2 = (\ell_A^{e_A} \ell_B^{e_B} \cdot f)^2 - 2 (\ell_A^{e_A} \ell_B^{e_B} \cdot f) - 1
$$
که به‌طور خلاصه خواهیم داشت:
$$ p^2 \mp 1 = (\ell_A^{e_A} \ell_B^{e_B} \cdot f )^2 \pm 2 \ell_A^{e_A} \ell_B^{e_B} \cdot f   $$
و از آنجا که 
$ (\ell_A^{e_A} \ell_B^{e_B} \cdot f) = p $
، بنابراین فرم بالا به‌صورت زیر خلاصه می‌شود:
$$ p^2 \mp 2p \mp 1 = (\ell_A^{e_A} \ell_B^{e_B} \cdot f)^2 $$
که اگر دوباره آن‌ را خلاصه کنیم، خواهیم داشت:
$$ (p \mp 1)^2 = (\ell_A^{e_A} \ell_B^{e_B} \cdot f)^2 $$
که همان مرتبه‌ی گفته شده با روش بروکر می‌باشد.

\subsection{پیدا کردن مولدهای زیرگروه تابی}\label{find_generators_of_torsion_points}

برای انتخاب نقاط مولد زیرگروه
$E_0[\ell_A^{e_A}]$
، می‌توان یک نقطه تصادفی 
$P \:  {\in}_R \: E_0(\mathbb{F}_{p^2}) $
انتخاب و آن را در 
${(\ell_B^{e_B} \cdot f )}^2$
ضرب کرد تا نقطه
$P'$
با مرتبه توانی از 
% $\ell_A^{e_A}$
$\ell_A$
حاصل شود. از آنجا که عامل‌های عدد اول
$p$،
$\ell_A^{e_A}$
و
$\ell_B^{e_B}$
می‌باشند، احتمالا 
$P'$
از مرتبه
$\ell_A^{e_A}$
خواهد بود؛ برای اثبات این ادعا می‌توان با ضرب 
$P'$
در توان‌هایی از 
$\ell_A$
آن را بررسی کرد. اگر بررسی موفقیت آمیز بود آنگاه 
$P_A = P'$
در نظر می‌گیریم در غیر اینصورت به دنبال یافتن نقطه‌ای دیگر برای
$P$
می‌شویم. برای به دست آوردن نقطه دوم مولد یعنی
$Q_A$
از مرتبه‌ی
$\ell_A$
، می‌توان از همین روش استفاده کرد.برای بررسی این که آیا نقطه
$Q_A$
از نقطه
$P_A$
متفاوت است ، می‌توان به راحتی با استفاده از زوجیت وایل و محاسبه
$e(P_A,Q_A)$
در میدان
$E[\ell_A]$
، بررسی کرد که آیا نتیجه از مرتبه 
$\ell_A$
می‌باشد یا خیر ؛ 
برای اطمینان از اینکه نقطه‌ي
$Q_A$
متفاوت از نقطه‌ی 
$P_A$
می‌باشد می‌توانیم از گزاره زیر استفاده کنیم:
\proposition{

اگر
$P_A , Q_A \in E[ \ell_A ]$
 و 
$ \ell_A $
 عددی اول باشد آنگاه 
$$ 
e_n(P_A,Q_A) = 1
~~ \text{اگر و تنها اگر} ~~
Q_A = k P_A 
$$
}

\refproof{~
\\
\begin{enumerate}
\item{
اگر فرض شود به ازای یک 
$k$
،
$Q_A = kP_A$
در این‌صورت:
$$ e_n(P_A,Q_A) = e_n(P_A,kP_A) = e_n(P_A,P_A)^k = 1^k = 1 $$
}

\item {
همچنین اگر 
$e_n(P_A,Q_A) = 1$
، در اینصورت
$R \in E[\ell_A]$
را چنان اختیار می‌کنیم که
$E[\ell_A] = \langle P,R \rangle$
، بنابراین 
$\partial = e_n(P_A,R)$
یک ریشه 
n
-ام اولیه واحد است. پس:
$$
Q_A \in E[n] = \langle P_A,R \rangle \longrightarrow \exists 0 \leqslant k,l \leqslant \ell_A - 1 ~~, ~~~~
Q_A = kP_A + \ell R
$$
اکنون :
$$ 1 = e_n(P_A,Q_A) = e_n(P,kP + \ell R) = e_n(P,P)^kr_n(P,R)^{\ell} = \partial^{\ell} $$
بنابراین
$ \partial ^ {\ell} = 1$
و درنتیجه
$\ell = 0$
، پس 
$Q_A = k P_A$.
}
\end{enumerate}~
} % end of refproof
\\
\textbf{توجه .}
انتخاب نقاط مولد ، هیچ گونه تاثیری روی امنیت این طرح ندارد ؛ از آنجا که هر کدام از نقاط مولد با استفاده از لگاریتم گسسته توسیع یافته، قابل تبدیل به یکدیگر می‌باشند. چنانچه در 
\cite{teske}
اشاره شده است این محاسبه به راحتی در زیرگروه
$E[\ell_A]$
قابل انجام می‌باشد. 
\subsection{تبادل کلید }\label{key_exchange}
یک از مهمترین ارکان هر سیستم رمزنگاری مربوط به تبادل کلید می‌باشد. به‌عبارت دیگر زمانی‌که یک سیستم رمزنگاری معرفی می‌شود در ابتدا بررسی می‌شود که آیا می‌توان پروتکل تبادل کلید را پیاده‌سازی کرد یا خیر. بعد از معرفی سیستم رمزنگاری همسانی-مبنا، آقای جائو در 
\cite{}
 به معرفی تبادل کلید در همسانی‌ها پرداخت. از آنجا که این موضوع در ادامه بحث مورد استفاده قرار می‌گیرد، این پروتکل رو تشریح می‌کنیم.
\\
 
پروتکل تبادل کلید نوعی از پروتکل دیفای-هلمن است که طبق شکل ۱ صورت می‌پذیرد. ایده‌ی کلی این پروتکل آن است که شخصی مانند آرش، همسانی 
$\phi$
و شخص دیگری همچون بابک همسانی 
$\psi$
را به عنوان کلیدخصوصی انتخاب می‌کنند و با یک خم سوپرسینگولار عمومی همچون
$E_0$
بااستفاده از پروتکل قدم‌زدن روی گراف به تولید یک خم خصوصی همچون
$E_A$
و
$E_B$
می‌پردازند که بیانگر کلیدخصوصی آنها همچون دیگر پروتکل‌های رمزنگاری می‌باشد. در ادامه با انجام محاسباتی که در ادامه تشریح خواهد شد به‌طور مجزا به تولید یک خم سوپرسینگولار همچون 
$E_{AB}$
خواهند پرداخت که به عنوان کلیدعمومی‌شان درنظر گرفته می‌شود.
\\
\begin{enumerate}
\item{
	در ابتدا، یک خم سوپرسینگولار دلخواه در میدان
	$\mathbb{F}_{p^2}$
	همچون
	$E_0$ 
	و دو جفت نقاط 
	$\{P_A,Q_A\}$
	و
	$\{P_B,P_B\}$
	که مولد زیرگروه‌های تابی
	$E_[\ell_A^{e_A}]$
	و
	$E_[\ell_B^{e_B}]$
	می‌باشند را به‌عنوان پارامترهای عمومی پروتکل درنظر می‌گیریم.
	
}
\item{
\begin{enumerate}
\item{
درادامه آرش دو عنصر تصادفی همچون
$m_A,n_A \in \mathbb{Z}/ \ell_A^{e_A} \mathbb{Z}$
(که هردو همزمان به 
$\ell_A$
بخش‌پذیر نیستند) را انتخاب می‌کند و همسانی
$\phi_{A} : E_0 \rightarrow E_A$
را که هسته‌ی آن
$K_A := \langle [m_A]P_A + [n_A]Q_A$
می‌باشد را محاسبه می‌کند.درادامه آلیس 
$\{ \phi_A(P_B) , \phi_A(Q_B) \} \subset E_A$
را نیز محاسبه می‌کند.
}
\item{
به‌طورمشابه، بابک نیز دو عنصر تصادفی همچون
$m_B,n_B \in \mathbb{Z}/ \ell_B^{e_B} \mathbb{Z}$
را انتخاب و همسانی
$\phi_{B} : E_0 \rightarrow E_B$
با هسته‌ی
$K_B := \langle [m_B]P_B + [n_B]Q_B$
را به‌همراه نقاط
$\{ \phi_B(P_A) , \phi_B(Q_A) \}$
محاسبه می‌کند.

}
\end{enumerate}

\item {
\begin{enumerate}
\item{
در ادامه آرش پس از دریافت 
$E_B$
و
$\phi_B(P_A) , \phi_B(Q_A) \in E_B$
از جانب بابک، به محاسبه‌ی همسانی
${\phi}'_A : E_B \rightarrow E_{AB}$
با هسته‌ی
$\langle [m_A]\phi_{B}(P_A) + [n_A]\phi_{B}(Q_A) \rangle$
می‌پردازد.

}
\item{
  بابک نیز با دریافت
$E_A$
 به محاسبه‌ی همسانی
${\phi}'_B : E_A \rightarrow E_{AB}$
با هسته‌ی
$\langle [m_B]\phi_{A}(P_B) + [n_B]\phi_{A}(Q_B) \rangle$
می‌پردازد.
}
\end{enumerate}
}

}

\item{
آرش و بابک برای دسترسی به یک کلیدخصوصی مشترک می‌توانند
$j$
-پایای خم زیر را محاسبه کنند:
$$
E_{AB} = {\phi}_B'(\phi_A(E_0)) = {\phi}_A'(\phi_B(E_0)) = 
E_0 / \langle [m_A]P_A + [n_A]Q_A , [m_B]P_B + [n_B]Q_B  \rangle
$$

}
\end{enumerate}





\subsection{ساده‌سازی نقاط تاب‌دار}\label{sampling_torsion_points}
% ===========================================================================================
% Algorithm 1  three-point ladder to compute P + [t]Q
% ===========================================================================================
\begin{algorithm}\label{algorithm_ladder}
	\caption{نردبان سه-نقطه‌ای برای محاسبه‌ی $P + [t]Q$}
	\begin{latin}
		%\resetlatinfont
		\textbf{Input :} ~ t,P,Q
		\begin{algorithmic}[1]
			\State Set $A=0, B=Q, C=P$
			\State Compute $Q-P ;$
			\For{ $ i= |t| \ \textbf{to} \ 1 $ }
			\State Let $t_i$ be the $i$-th bit of t;
			\If {$t_i = 0 $} 
			\State $A=2A, B=dadd(A,B,Q), C=dadd(A,C,P);$
			\Else
			\State $A=dadd(A,B,Q), B=2B, C=dadd(B,C,Q-P);$
			\EndIf
			\EndFor	
		\end{algorithmic}
		\textbf{Output :} ~ $C=P+[t]Q$
	\end{latin}
\end{algorithm}~
% ===========================================================================================
% ===========================================================================================
در طرح خود از نقاط تصادفی متنوعی با مرتبه‌ی خاص همچون 
$\ell_A^{e_A}$
و
$\ell_B^{e_B}$
به‌مراتب برای ساخت یک زیرگروه استفاده می‌کنیم. از آنجا که نقاط موردنظر ما از زیرگروه‌های تابی  
$E[\ell_A^{e_A}]$
و
$E[\ell_B^{e_B}]$
با دو مولد
$P$
و
$Q$
ساخته می‌شوند لذا این نقاط به فرم
$\langle [m]P + [n] Q \rangle $
خواهند بود. البته
$m$
و
$n$
همزمان نباید با
$\ell^e$
موردنظر بخش‌پذیر باشند. بنابراین نتیجه می‌گیریم که که اگر روشی ارائه دهیم تا ساخت این زیرگروه‌ها با محاسبات کمتری انجام پذیرند، به‌طور کلی طرح ما بهینه‌تر خواهد شد.
\\
می‌توان فرض کرد که هر
$m$
، دارای عنصر وارون در پیمانه‌ی مرتبه‌ی گروه می‌باشد( این فرض هیچ خدشه‌ای به زیرگروه وارد نمی‌کند). در این حالت 
$R' = P + [m^{-1}n]Q$
زیرگروهی همانند دیگر مولدها خواهد بود. محاسبه 
$R'$
با روش استاندارد  
\textbf{دوبرابر-و-جمع} 
\LTRfootnote{double-and-add}
نیاز به نصف عملیات محاسبات
$[m]P + [n]Q$
معمولی را دارا می‌باشد( برای روش های بهتر محاسبه عملیات معمولی به مراجعه 
\cite{ antipa, elgamal, solinas}
شود). با این حال،  محاسبه 
$P + [m^{-1}n]Q$
با روش دوبرابر-و-جمع، یک حفره امنیتی (اشکال بزرگ) را داراست : در برابر حملات 
\textbf{آنالیز قدرت ساده } 
یا
\textbf{SPA}
\cite{spa}
آسیب پذیر می‌باشد. برای جلوگیری از این حمله می‌توان از روش
\textbf{نردبان مونت‌گومری}
\LTRfootnote{Montgomery ladder}
\cite{montgomery}
برای محاسبه 
$[m^{-1}n]Q$ 
استفاده کرد و سپس 
$P$
را به آن اضافه کرد، اما این روش به طور قابل ‌توجهی کند می‌باشد.
به‌منظور رفع دو مشکل کندی و حمله‌ی
\text{SPA}
، الگوریتم
\ref{algorithm_ladder}
 را ارائه می‌دهیم که بیانگر یک روش بسیار موثرتری  می‌باشد و مستقیما 
$P + [m^{-1}n]Q$
را محاسبه می‌کند. ایده اصلی این طرح ساده است : در هر تکرار ، ثبات های 
$A$
و
$B$
و
$C$
محتوی مقدارهای به ترتیب
$[x]Q$
و
$[x+1]Q$
و
$P+[x]Q$
می ‌باشند ، که 
$x$
حاوی ارزش چپ ترین بیت
$m^{-1}n$
می‌باشد.تابع 
$dadd(A,B,C)$
مورد استفاده شده در الگوریتم نیز معرف جمع تفاضلی 
\LTRfootnote{differential addition}
\cite{montgomery}
می‌باشد. 
\\
پیاده سازی جمع تفاضلی در خم‌های مونت‌گومری به کارآمدی روش دوبرابر-و-جمع ساده روی خم های دوقولوی ادوارد
\LTRfootnote{twisted Edwards curves}
\ref{model_choice}
می‌باشد، بنابراین درادامه به معرفی خم‌های مونت‌گومری خواهیم پرداخت.

\subsection{\bf   محاسبه همسانی‌های با درجه هموار}\label{smooth_isogeny}
\LTRfootnote{Computing smooth degree isogenies}

محاسبه‌ی همسانی یکی از پرهزینه‌ترین محاسبات در سیستم‌های همسانی‌-مبنا می‌باشند. از آنجا که در طرح خود نیز به‌مراتب به محاسبه‌ی همسانی‌ها با درجه‌ی معینی می‌پردازیم بنابراین  لازم است تا روشی سریع برای این امر معرفی کنیم. البته این روش می‌تواند در تمامی طرح‌ها مورداستفاده قرار گیرد، به‌عنوان مثال می‌توان در محاسبات همسانی در پروتکل تبادل کلیدی که در بخش قبل بین آرش و بابک انجام می‌پذیرد اشاره کرد.
\\
 فرض کنیم 
$E$
یک خم بیضوی و 
$R$
یک نقطه از مرتبه 
$\ell^e$
باشد. هدف ما محاسبه تصویر خم 
$E/ \langle R \rangle $
و ارزیابی همسانی 
$\phi : E \rightarrow E/ \langle R \rangle $
در بعضی نقاط روی خم 
$E$
می‌باشد. 
% ==============================================================================================
\begin{figure}[H]\label{}
	\begin{center}
		
		
		\caption{
			ساختمان محاسبات ساخت 
			$\phi = {\phi}_5 \circ \cdots  \circ {\phi}_0$    
		}
		
	\end{center}
\end{figure}
% ==============================================================================================
اگر درجه‌ی نگاشت 
$\phi$
هموار باشد، می‌توان آن را به زنجیره‌ای از
$\ell$
-همسانی ها تجزیه کرد. اگر
$E_0 = E$
و
$R_0 = R$
در نظر بگیریم ، آنگاه برای هر 
$0 \leq i < e $
می‌توان مقادیر زیر را در نظر گرفت :
$$
E_{i+1} = E_i / \langle \ell^{e-i-1}R_i \rangle , \quad
\phi_i : E_i \rightarrow E_{i+1} , \quad
R_{i+1} = \phi_i(R_i).
$$
چنانکه 
$E / \langle R \rangle = E_e$
و
$\phi = \phi_{e-1} \circ \cdots \circ \phi_0$
می‌باشد.

توجه به این نکته لازم است که از آنجا که زیرگروه 
$\ell$
-تابی 
$\langle R_i \rangle $
خم 
$E_i$
مشخص می‌باشند ، 

خم بیضوی 
$E_{i+1}$
و همسانی
$\phi_i$
می‌توانند توسط فرمول ولو 
\LTRfootnote{Velu's formulas}
\cite{velu}
به راحتی محاسبه شوند.
در 
\cite{jao2011towards}
، دو پیشنهاد برای داشتنی پیچیدگی درجه دو برای 
$e$
بیان شده است  ؟؟؟؟؟.
% به هر حال می‌توانیم این کار را بهتر انجام دهیم. 
\\
شکل بالا خلاصه‌ای از ساختار محاسباتی مسئله برای 
$e = 6$
می‌باشد. نقطه‌های توپر این گراف نشان دهنده نقاط می‌باشد. نقطه‌های موجود در یک سطح افقی نشان دهنده آن است که این نقاط از یک مرتبه می‌باشند و همچنین نقطه‌های روی خط مورب چپین نشان دهنده آن است که این نقطه‌ها همگی متعلق به یک خم می‌باشند. یال‌های نقطه‌چین همگی جهت‌دار و به سمت پایین می‌باشند ؛ یال‌های چپین معرف آن هستند که نقطه‌ها 
$\ell$
برابر شده‌اند و یال‌های راست‌چین هم یک 
$\ell$
ـ همسانی را نشان می‌دهند.
% try to better writing ..
در ابتدای اجرای الگوریتم ، تنها نقطه 
$R_0$
را در اختیار داریم. به بیان دیگر هدف ما در این الگوریتم  محاسبه تمام نقاط روی خط پایانی توسط نقطه آغازین 
$R_0$
می‌باشد (ورودی این الگوریتم نقطه 
$R_0$
و خروجی این الگوریتم نقاط 
$[\ell^5]R_0$
،
$[\ell^4]R_1$
،
$[\ell^3]R_2$
،
$[\ell^2]R_3$
،
$[\ell^1]R_4$
و
$R_5$
می‌باشد).
در واقع با دانستن نقطه 
$[\ell^{e-i-1}]R_i$
، می‌توانیم هسته همسانی
$\phi_i$
را به تعداد
$\mathcal{O}(\ell)$
جمع نقاط ، محاسبه کنیم ؛ که در این صورت پیچیدگی محاسبات به طور قابل توجهی کم می‌شود. در ادامه می‌توانیم از طریق فرمول ولو ، همسانی 
$\phi_i$
و خم 
$E_{i+1}$
را محاسبه کنیم. 
% complete next statemnet correctly !!!
\\
برای فهم بیشتر این الگوریتم مراحل ذکر شده در مثال 
$e=6$
را مرحله به مرحله نمایش می‌دهیم :
\begin{itemize}
	
	\item[] {}
	\begin{flushleft}
		$
		i=0 \Rightarrow \quad 
		E_1 = E_0 / \langle \ell^{4}R_0 \rangle , \quad 
		\phi_0 : E_0 \rightarrow E_1 , \quad 
		R_1 = \phi_0(R_0)
		$
	\end{flushleft}
	
	\item[] {}
	\begin{flushleft}
		$
		i=1 \Rightarrow \quad 
		E_2 = E_1 / \langle \ell^{3}R_1 \rangle , \quad 
		\phi_1 : E_1 \rightarrow E_2 , \quad 	R_2 = \phi_1(R_1) = \phi_1(\phi_0(R_0))
		$
	\end{flushleft}
	
	\item[] {}
	\begin{flushleft}
		$
		i=2 \Rightarrow \quad 
		E_3 = E_2 / \langle \ell^{2}R_2 \rangle , \quad 
		\phi_2 : E_2 \rightarrow E_3 , \quad 	R_3 = \phi_2(R_2) = \phi_2(\phi_1(\phi_0(R_0)))
		$
	\end{flushleft}
	
	\item[] {}
	\begin{flushleft}
		$
		i=3 \Rightarrow \quad 
		E_4 = E_3 / \langle \ell^{1}R_3 \rangle , \quad 
		\phi_3 : E_3 \rightarrow E_4 , \quad 	R_4 = \phi_3(R_3) = \phi_3(\phi_2(\phi_1(\phi_0(R_0))))
		$
	\end{flushleft}
	
	\item[] {}
	\begin{flushleft}
		$
		i=4 \Rightarrow \quad 
		E_5 = E_4 / \langle \ell R_4 \rangle , \quad 
		\phi_4 : E_4 \rightarrow E_5 , \quad 	R_5 = \phi_4(R_4) = 
		\phi_4(\phi_3(\phi_2(\phi_1(\phi_0(R_0)))))
		$
	\end{flushleft}
	
	\item[] {}
	\begin{flushleft}
		$
		i=5 \Rightarrow \quad 
		E_6 = E_5 / \langle R_5 \rangle , \quad 
		\phi_5 : E_5 \rightarrow E_6 , \quad 	R_6 = \phi_5(R_5) = 
		\phi_5(\phi_4(\phi_3(\phi_2(\phi_1(\phi_0(R_0))))))
		$
	\end{flushleft}
	
\end{itemize}


\subsection{\bf انتخاب مدل}\label{model_choice}

\input{montgomery}

\input{parameter_sizes}

